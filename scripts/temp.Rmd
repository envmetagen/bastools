---
title: "Plotting barcode gaps from self-blast results"
html_notebook: default
subtitle: ''
classoption: portrait
output: html_document
includes:  
      #in_header: rmarkdownsettings.txt
      extra_dependencies: ["float"]
---
# Prerequisites. The input is the results of a "thorough" blast against a large database, ideally nt
## e.g. blastn -query my.fasta -db nt -outfmt '6 qseqid saccver staxid pident sseq' -evalue 1 -max_target_seqs 50 -max_hsps 1 -word_size 11 -perc_identity 50 -qcov_hsp_perc 98 -gapopen 0 -gapextend 2 -reward 1 -penalty -1 -dust no -out my.blast.tsv
## In any case I recommend such settings, although it takes longer, as they are much more informative and useful for metabarcoding.
```{r load functions, eval=TRUE, results='hide',echo=F}
knitr::opts_chunk$set(fig.pos = "!H", out.extra = "")
source(paste0(bastoolsDir,"master_functions.R"))
library(ggplot2)
library(tidyverse)
options(httr_oob_default = TRUE)
all.stats<-list()
TaxlevelTestall<-c("F","G","S")

read.and.format.full.blast<-function(input,minpident=80){
  
  output<-list()
  
    #read full blast results
    fullblast<-data.table::fread(input,data.table = F)
    
    fullblast<-data.table::fread(input,data.table=F,
  select = c("qseqid","saccver","taxids","pident","sseq") )
    
    #remove hyphens sseq
    fullblast$sseq<-gsub("-","",fullblast$sseq)
    
    #need to reduce db size. not sure of best option!
    ##currently- for fasta using the saccver that had the best hit in original blast and disregarding saccvers whose best hit was below 80%. i.e. those with best hit below 80% will just not be tested #9458
    #for database using the same
    
    #keep best hit per saccver=22050
    #keep best per saccver, but only those that had >70% pidents=16390, 80%=9483
    #keep best hit per sseq=29796
    #keep best hit per staxid=9419, 
    #if then only keeping unique sseqs->7953 (could then map results back later,but I have not implemented this)
    #keep best hit per species=8765 (think this is not ideal)
    fullblast<-fullblast[order(fullblast$pident,decreasing = T),]
    #fullblast<-fullblast[!duplicated(fullblast$saccver),] 
    #testing with one per saccaver instead of taxid, not much difference. actually led toincorrect flags, because sometimes there are so many of one taxon that the blast does not find the original taxon
    fullblast<-fullblast[!duplicated(fullblast$saccver),] #too many seqs
    fullblast<-fullblast[fullblast$pident>minpident,] #is this dodgy? 
    
    #limit to max 50 per taxid to overcome the "thunnus issue"
    fullblast_spl<-split(fullblast,fullblast$taxids)
    for(i in 1:length(fullblast_spl)){
      if(nrow(fullblast_spl[[i]])>50) fullblast_spl[[i]]<-fullblast_spl[[i]][1:50,]
    }
    
    fullblast<-do.call(rbind,fullblast_spl)
    
    
    #make new header names with taxids, for building db
    fullblast$seq.name<-paste0(fullblast$saccver," taxid=", fullblast$taxids,"; ")
    
    #change sseq to seq.text, for phylotools
    colnames(fullblast)<-gsub("sseq","seq.text",colnames(fullblast)) 
    
    #add lineages for later
    fullblast<-add.lineage.df(fullblast,ncbiTaxDir)
    fullblast$origpathS<-paste(fullblast$K,fullblast$P,fullblast$C,fullblast$O,fullblast$F,fullblast$G,fullblast$S,sep=";")
    
    ##other options
    #1. a full database, i.e. best seq for each saccevr (22k), the same query as already. Maybe not much slower, and can still find errors,
    #with filterB, but not as many I guess
    
    
    # #keep multiple human, e.g 100
    # fullblastdbh<-fullblast[fullblast$origpathS=="Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens",]
    # if(nrow(fullblastdbh)>100) fullblastdbh<-fullblastdbh[1:100,]
    # fullblastdbexh<-fullblast[fullblast$origpathS!="Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens",]
    # 
    # fullblastdbexh<-fullblastdbexh[!duplicated(fullblastdbexh$taxids),] #3232+606 extra human
    # fullblastdb<-rbind(fullblastdbexh,fullblastdbh)
    # 
    # rm(fullblastdbh)
    # rm(fullblastdbexh)
    # 
    # output[[1]]<-fullblast  #the fasta of all saccvers above 80%
    # output[[2]]<-fullblastdb #the database of only taxids #not working, incorrectly assigned errors
    
    return(fullblast)
  } 
```

## STEP1 SELF BLAST
### Convert the sseqs into a blast database, select all saccvers that had >80% identity. Output a krona plot of the database, to see what is in it
```{r self blast, eval=TRUE,echo=F}

if("selfblast" %in% steps) {
  
  t1<-Sys.time()
  
  fullblast<-read.and.format.full.blast(input) 
  
  #remove known flags
  if(!is.null(known_flags)) {
    kf<-data.table::fread(known_flags,data.table = F,header = F)
    fullblast<-fullblast[!fullblast$qseqid %in% kf$V1,]
    fullblast<-fullblast[!fullblast$saccver %in% kf$V1,]
  }
  
  #MAKE KRONA OF DB
  x<-as.data.frame(table(fullblast$origpathS))
  colnames(x)<-c("taxon","count")
  #x<-data.frame(taxon=fullblast$origpathS,count=1)
  bas.krona.plot(taxatable = x,out = paste0(outDir,krona_html_db),KronaPath = KronaPath)
  
  #use the max count for a given taxon as the max blast hits, otherwise some hits will be erroneously flagged
  #e.g. 
# thunnus	AB097669.1	so many seqs in this genus, that this one is not in top 100
# thunnus	GQ461734.1	so many seqs in this genus, that this one is not in top 100
# thunnus	AY958655.1	so many seqs in this genus, that this one is not in top 100

  #mx_targets<-max(x$count)
  #files just got too big for R, limited now to 150
  
  message("krona plot for self-blast database saved to ", paste0(outDir,krona_html_db))
  
  phylotools::dat2fasta(fullblast[,c("seq.name","seq.text")],paste0(outDir,"tempBLASTDB.fasta"))
  #phylotools::dat2fasta(fullblast[[1]][,c("seq.name","seq.text")],paste0("tempBLASTquery.fasta"))
  
  rm(fullblast)
  
  #make blastdb using metabinkit
  system2("metabinkit_blastgendb",c("-f",paste0(outDir,"tempBLASTDB.fasta"),"-o", paste0(outDir,"tempBLASTDB"),"-c"),wait = T)
  
  message("straight SELF-BLAST running...")
  
  system2(command = "blastn",
          args=c("-query", paste0(outDir,"tempBLASTDB.fasta"), "-db",paste0(outDir,"tempBLASTDB"),"-outfmt",
                 "'6 qseqid saccver staxid pident'","-evalue",1,"-num_threads", 64, "-max_target_seqs", 
                 70, "-max_hsps",1,"-word_size", 11,"-perc_identity", 70,"-qcov_hsp_perc",98,
                 "-gapopen", 0, "-gapextend", 2, "-reward", 1, "-penalty", -1, "-dust","no", "-out", 
                 paste0(outDir,selfblastout)), wait = T)
  
  #hard coded for now, note the "taxids" rather than "staxid", which metabin does not accept
  headers<-paste0("'1i",paste(c("qseqid", "saccver", "taxids", "pident"),collapse = "\t"),"'")
  
  system2("sed",c("-i", headers, paste0(outDir,selfblastout)),wait = T)
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("self-blast complete in ",t3," mins")
  
} else message("This step was not set to run")

```

## find_db_errors
### For each taxonomic level (F,G,S) look for potentially misassigned entries (see output for rules). Output a table of the results for manual inspection
### So far haven seen any flagged accessions that seem incorrectly flagged. But not all errors are caught. Main case is when there are multiple erroneously labelled entries of the same taxon. 
```{r find_db_errors, eval=TRUE,echo=F}
if("find_db_errors" %in% steps) {
  
 
  message("newly flagged accession numbers")
  print(flagged$V1)
  
} else message("This step was not set to run")

message("outside chunk")
  flagged
```

# calc_bar_gap
## basically, plot the blast results indicating the within-taxon variation vs among-taxon variation at F, G & S levels to help to choose appropriate binning thresholds.
## By default, flagged entries from previous step are excluded.  
## What we want to use in the end is the lowest %identity (to limit our loss of reads assigned at each level) that excludes other taxa (to increase resolution). In practice this is a trade-off because we often get overlap of within-taxon variation and among-taxon variation. Feeding these % identities to metabinkit (lca approach), we will never get "wrong" results (unless we still have database errors), but we will just lose resolution if the % identity is too low OR too high. E.g. if species threshold is 95% (caseA), many queries will have hits to multiple species and wont be binned at species-level, but if species threshold is 100% (caseB) many queries will have no hits passing this filter and so also wont be binned at species-level. CaseA can be partially overcome by applying a low "Top.." value.  E.g. if species threshold is 95% but a Top of 1% has been applied, then there will not be as many hits surviving the filters and we will get higher numbers of queries at species-level. How to choose tops? Is using a low top always ok?
```{r plots, eval=TRUE,echo=F,fig.height=7,fig.width=10}
 #STEP3 calculate barcoding gaps
if("calc_bar_gap" %in% steps) {
  
  t1<-Sys.time()
  
  message("Limiting plots to ",plot.limit.taxon)
  
  #read and format fullblast results
  fullblast<-read.and.format.full.blast(input)
  
  #read self-blast results
  ax<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
    
  #add origpath
  ax<-merge(ax,fullblast[,c("saccver", "K","P","C","O","F","G","S","seq.text")], by.x = "qseqid", by.y = "saccver",all.x = T,all.y = F)
  
  rm(fullblast)
  
  #change colnames
    ax$qseq<-ax$seq.text
    ax$seq.text<-NULL
    ax$Ko<-ax$K
    ax$Po<-ax$P
    ax$Co<-ax$C
    ax$Oo<-ax$O
    ax$Fo<-ax$F
    ax$Go<-ax$G
    ax$So<-ax$S
    ax$K<-NULL
    ax$P<-NULL
    ax$C<-NULL
    ax$O<-NULL
    ax$F<-NULL
    ax$G<-NULL
    ax$S<-NULL
    
    #add full origpath
    ax$origpath<-paste(ax$Ko,ax$Po,ax$Co,ax$Oo,ax$Fo,ax$Go,ax$So,sep=";")
    #add hitpath 
    ax<-add.lineage.df(ax,ncbiTaxDir)
    ax$hitpath<-paste(ax$K,ax$P,ax$C,ax$O,ax$F,ax$G,ax$S,sep=";")
    #mincols (note the object name is misleading because these are not ex_flagged)
    ax_exflagged<-ax[,c("qseqid","saccver","taxids","pident","origpath","hitpath")]
    
    #
    if(use_flagged_accessions_bcg) {
      message("Excluding flagged accessions")
    #ax_exflagged<-data.table::fread(paste0(outDir,corrected_db),data.table=F,
    #select = c("qseqid","saccver","taxids","pident","origpath","hitpath"))
    flagged<-data.table::fread(paste0(outDir,flagged_accessions),data.table = F,header = F)
     ax_exflagged<-ax_exflagged[!ax_exflagged$qseqid %in% flagged$V1,]
      ax_exflagged<-ax_exflagged[!ax_exflagged$saccver %in% flagged$V1,]
      
    #remove known flags
      if(!is.null(known_flags)) {
        kf<-data.table::fread(known_flags,data.table = F,header = F)
        ax_exflagged<-ax_exflagged[!ax_exflagged$qseqid %in% kf$V1,]
        ax_exflagged<-ax_exflagged[!ax_exflagged$saccver %in% kf$V1,]
      }
    } else message("Not excluding any accessions")
    
    rm(ax)
  
    plot.list.loop<-list()
    plot.list.all<-list()
    perc_among_res<-list()
    overlaps<-list()
    potential.errors.out<-list()
    for(h in 1:3){
    
      TaxlevelTest<-TaxlevelTestall[h]
      ax_exflagged$origtaxleveltest<-path.at.level(ax_exflagged$origpath,TaxlevelTest)
      ax_exflagged$hitleveltest<-path.at.level(ax_exflagged$hitpath,TaxlevelTest)
  
      #within taxlevel vs among tax level range
      newtab<-data.frame(matrix(ncol=6,nrow = length(unique(ax_exflagged$origtaxleveltest))))
      colnames(newtab)<-c("taxon","max_within","min_within","max_among","min_among","max_among_saccver")
      
      
      ax_exflagged.spl<-split(ax_exflagged,ax_exflagged$origtaxleveltest)
      
      for(i in 1:length(ax_exflagged.spl)){
        temp<-ax_exflagged.spl[[i]]
        taxoni<-temp$origtaxleveltest[1]
        newtab$taxon[i]=taxoni
        newtab$max_within[i]=max(temp[temp$hitleveltest==taxoni,"pident"])
        newtab$min_within[i]=min(temp[temp$hitleveltest==taxoni,"pident"])
        
        if(nrow(temp[temp$hitleveltest!=taxoni,])>0){
          newtab$max_among[i]=max(temp[temp$hitleveltest!=taxoni,"pident"])
          newtab$min_among[i]=min(temp[temp$hitleveltest!=taxoni,"pident"])
          newtab$max_among_saccver[i]=temp[temp$hitleveltest!=taxoni,"saccver"][1]
        } else {
          #stop(i)
          newtab$max_among[i]=0
          newtab$min_among[i]=0
        }
      }
      
      #print overlaps for inspection later
      overlaps[[h]]<-unique(newtab[newtab$max_among>=99,"taxon"])
      
      message("Taxa with among-taxa variarion >= 99% at ",TaxlevelTestall[h]," level.
              Inspect ",further_potential_errors," for further details and to manually flag accessions")
      print(overlaps[[h]])
      
      # if(TaxlevelTestall[h]=="F") print.details.among<-print.details.among.F
      # if(TaxlevelTestall[h]=="G") print.details.among<-print.details.among.G
      # if(TaxlevelTestall[h]=="S") print.details.among<-print.details.among.S
      # 
      #if(print.details.among){
      #message("Details of hits for taxa with among-taxa variarion >= 99% at ",TaxlevelTestall[h]," level.")
      potential.errors<-list()
        for(j in 1:length(overlaps[[h]])){
          #message(overlaps[[h]][j])
          xy<-ax_exflagged[ax_exflagged$origtaxleveltest==overlaps[[h]][j],] 
          xy<-xy[xy$pident>=99,] 
          potential.errors[[j]]<-xy[xy$hitleveltest!=overlaps[[h]][j],]
        }
      
      potential.errors.out[[h]]<-do.call(rbind,potential.errors)
      potential.errors.out[[h]]$level<- TaxlevelTest
    
  
    #plot
    newtablong<-reshape2::melt(newtab[,c("taxon","max_within","min_within","max_among","min_among")],id.vars="taxon")
    
    #plot limit
    if(!is.null(plot.limit.taxon)) newtablong<-newtablong[grep(plot.limit.taxon,newtablong$taxon),]
     
    newtablong$groups<-""
    newtablong$groups[newtablong$variable=="max_within" | newtablong$variable=="min_within"]<-paste("within",TaxlevelTest,"range")
    newtablong$groups[newtablong$variable=="max_among" | newtablong$variable=="min_among"]<-paste("among",TaxlevelTest,"range")
    
    plota<-ggplot(newtablong,aes(x = taxon,y = value,colour=groups,group=interaction(taxon,groups)))+geom_point()+
      theme(axis.text.x=element_text(size=8,angle=45, hjust=1),legend.title = element_blank(),
            panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.background = element_blank(),
            axis.line = element_line(colour = "black"))+
      geom_line()+ylab("Percentage identity")+xlab("")
    
    #add to ax_exflagged file to make it easy to look up later
    # ax_exflagged<-merge(ax_exflagged,newtab[,c("taxon","max_among_saccver")],by.x="origtaxleveltest",by.y="taxon")
    # if(TaxlevelTest=="S") ax_exflagged$max_among_S<-ax_exflagged$max_among_saccver
    # if(TaxlevelTest=="G") ax_exflagged$max_among_G<-ax_exflagged$max_among_saccver
    # if(TaxlevelTest=="F") ax_exflagged$max_among_F<-ax_exflagged$max_among_saccver
    # ax_exflagged<-ax_exflagged[,-match("max_among_saccver",colnames(ax_exflagged))]
    
    #counts. 
    values<-seq(100,50,-1)
    res<-data.frame(pident=values,nTaxaWithin=0,nTaxaAmong=0)
    for(i in 1:length(values)){
      xx<-newtablong[newtablong$value>=values[i],]
      res[i,"nTaxaWithin"]<-length(unique(xx[grep("within",xx$groups),"taxon"])) 
      res[i,"nTaxaAmong"]<-length(unique(xx[grep("among",xx$groups),"taxon"]))
    }
    
    #plot res
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt$nTaxa<-resmelt$value
    
    plotb<-ggplot(resmelt,aes(x = pident,y = nTaxa,colour=variable))+geom_point()
      
    res$percent_among<-res$nTaxaAmong/res$nTaxaWithin*100
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt<-resmelt[resmelt$variable=="percent_among",]
    resmelt$percent_among<-resmelt$value
    
    plotc<-ggplot(resmelt,aes(x = pident,y = percent_among))+geom_point()
    
    #table of perc_within
    resx<-res[res$pident %in% c(100,99,98,97,96,95,90,85,80,75,70,65,60,50),]
    resx$percent_among<-round(resx$percent_among,digits = 0)
    perc_among_res[[h]]<-resx
    
    plot.list.loop[[1]]<-plota
    plot.list.loop[[2]]<-plotb
    plot.list.loop[[3]]<-plotc
    plot.list.all[[h]]<-plot.list.loop
    
    # #table of tops (diff)
    # newtab$diff<-newtab$min_within-newtab$max_among
    # #plot limit
    # if(!is.null(plot.limit.taxon)) newtab<-newtab[grep(plot.limit.taxon,newtab$taxon),]
    # ##change diff to zero if negative
    # newtab$diff[newtab$diff<0]<-0
    # 
    # diffs<-newtab[newtab$diff %in% c(100,95,90,85,80,75,70,65,60,50),]
    # resx$percent_among<-round(resx$percent_among,digits = 0)
    # perc_among_res[[h]]<-resx
    # 
    # ggplot(newtab,aes(x = taxon,y = diff))+geom_point()+
    #   theme(axis.text.x=element_text(size=8,angle=45, hjust=1),legend.title = element_blank(),
    #         panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.background = element_blank(),
    #         axis.line = element_line(colour = "black"))
    
    }
    
    #gather all potential errors and save in file
  potential.errors.out<- do.call(rbind,potential.errors.out)
  potential.errors.out<-potential.errors.out[,c("qseqid","saccver","taxids", "pident" ,"origpath","hitpath","level")]
  write.table(potential.errors.out,paste0(outDir,further_potential_errors),row.names=F,quote=F,sep="\t")
    
  #plots
  for(h in 1:3){
    print(plot.list.all[[h]][[1]])  
    print(plot.list.all[[h]][[2]])  
    print(plot.list.all[[h]][[3]])  
  }
  
  #reorder ax
  # ax_exflagged<-ax_exflagged[order(ax_exflagged$qseqid,ax_exflagged$pident,decreasing = T),]
  # ax_exflagged<-ax_exflagged[,c("qseqid","saccver","taxids", "pident","origpath", "hitpath","max_among_S" ,"max_among_G" ,"max_among_F" )] 
  # 
  # message("Adding accession numbers of closest taxon to ",paste0(outDir,corrected_db))
  # write.table(ax_exflagged,file = paste0(outDir,corrected_db),quote = F,sep = "\t",row.names = F)

  message("Family level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[1]])
  message("Genus level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[2]])
  message("Species level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[3]])
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("calculating barcode gaps in ",t3," mins")
  
} else message("This step was not set to run")
    
```

# metabin
```{r metabin, eval=TRUE,echo=F,fig.height=7,fig.width=10}
 #STEP4 metabin
#what to do here? loop tops? loop blast?
#already found pidents. Just tops remaining
#use flagged accessions?
if("metabin" %in% steps){
  
  #setwd(outDir)
  
  t1<-Sys.time()
  
  tops<-c(0,1,2,5,10,100)
  outfiles<-""
  l=0
  for(j in 1:length(tops)){
        l=l+1
        
        outfiles[l]<-paste0(outDir,paste0(metabin_out,"_top",tops[j]))
        if(use_flagged_accessions){
        system2("metabin",c("-i",input, "-o",outfiles[l], "--FilterFile",paste0(outDir,flagged_accessions), "--FilterCol","saccver", "-S",
                            98,"-G", 95
                         ,"-F", 85,"-A", 70, "--TopSpecies", tops[j],"--TopGenus",
                         tops[j],"--TopFamily", tops[j]
                         ,"--TopAF", 100,"--no_mbk"),wait=T)
        } else {
          system2("metabin",c("-i",input, "-o",outfiles[l], "-S", 98,"-G", 95
                         ,"-F", 85,"-A", 70, "--TopSpecies", tops[j],"--TopGenus",
                         tops[j],"--TopFamily", tops[j]
                         ,"--TopAF", 100,"--no_mbk"),wait=T)
        }
  }
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("metabin complete in ",t3," mins")
} else message("This step was not set to run")

```