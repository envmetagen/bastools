---
title: "Processing a taxatable post MBC and illumina_post_MBC_script2.R"
html_notebook: default
subtitle: ''
classoption: portrait
output: html_document
---

## read and print settings
```{r, eval=TRUE,echo=F}
source("/home/tutorial/TOOLS/bastools/project_configs/CRAY_trnL_FINAL_SWABS_POST_REBIN_SCRIPT.config.R")

message("settings:
        ")
print(ls.str())
```


```{r, eval=TRUE, results='hide',echo=F}
source(paste0(bastoolsDir,"master_functions.R"))
library(ggplot2)
library(dplyr)
options(httr_oob_default = TRUE)
all.stats<-list()
stepcounter<-0
```

## organise mastersheet
```{r, eval=TRUE,echo=F}
master_sheet<-google.overlord(url = ss_url,tokenDir=bastoolsDir,email=email)

##subset master sheet for this study 
message("Subsetting datasheet")
ms_ss<-subset_mastersheet(master_sheet, subsetlist)
#check again to see the subset made sense
master_xtabs(ms_ss,columns=c(names(subsetlist)))

```

## import taxatabs
```{r, eval=TRUE,echo=F, results='hide'}
#import taxtabs
all.taxatabs<-bas.merge.taxatabs(taxatabs)

#make new taxa table based on subsetted master sheet
all.taxatabs.ss<-cbind(taxon=all.taxatabs$taxon,all.taxatabs[colnames(all.taxatabs) %in% ms_ss$ss_sample_id])

#remove 0 reads
all.taxatabs.ss<-rm.0readtaxSam(all.taxatabs.ss)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(taxatab = all.taxatabs.ss,stepname = "start")

#rank stats
dxns.by.rank(all.taxatabs.ss)
```

## remove problem taxa - usually human, predator, NAs and no_hits
```{r, eval=TRUE,echo=F}
message("Removing no_hits")
all.taxatabs.ss<-all.taxatabs.ss[all.taxatabs.ss$taxon!="no_hits;no_hits;no_hits;no_hits;no_hits;no_hits;no_hits",]

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "rm.nohits")

message("Removing NAs - sequences that had blast hits but were not assigned to any taxon")
all.taxatabs.ss<-all.taxatabs.ss[all.taxatabs.ss$taxon!="NA;NA;NA;NA;NA;NA;NA",]
all.taxatabs.ss<-all.taxatabs.ss[all.taxatabs.ss$taxon!="unknown;unknown;unknown;unknown;NA;NA;NA",]

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "rm.non-assigned")

message("Removing problem taxa")
all.taxatabs.ss<-rm.taxa(taxatab = all.taxatabs.ss,taxaGrep = problemTaxa)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "rm.problem")
```

## apply taxon and sample filters
```{r, eval=TRUE,echo=F}
#Filter samples before removing the NAs and no_hits (0.1%)
all.taxatabs.ss<-taxon.filter.solo.df(taxatab = all.taxatabs.ss,taxonpc = taxonpc)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "taxonpc")

all.taxatabs.ss<-sample.filter.solo(taxatab = all.taxatabs.ss,samplepc=samplepc)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "samplepc")
```

## apply detection filter
```{r, eval=TRUE,echo=F}
#check with removing detections
message("Applying detection filter")
all.taxatabs.ss<-filter.dxns(taxatab = all.taxatabs.ss,filter_dxn = filter_dxn)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "dxnfilter")
```

## inspect negatives, print plots for only those taxa detected in both negatives and real samples
```{r, eval=TRUE,echo=F}
message("Checking negs")
negatives<-negs.stats(taxatab=all.taxatabs.ss,ms_ss = ms_ss,real=real,ex_hominidae=F)

message("Making quantile plots to help deciding dxn_filter threshold")
for(i in 1:length(negatives) ) {
  df<-negatives[[i]]
  if(length(colnames(df))>0){
    title<-names(negatives)[i]
    plot1<-qplot.taxatab(taxatab = df)
    plot1<-plot1 + ggtitle(label = title)
    print(plot1)
  }
}

message("Making barplots for only those taxa detected in both negatives and real samples - to help decide taxon filter and rm.contaminants filter")
plotlist1<-plot.negs.vs.real(taxatab = all.taxatabs.ss,ms_ss = ms_ss,real = real)

for(i in 1:length(plotlist1)){
  print(plotlist1[[i]])
}

message("Making barplots for only those taxa detected in both negatives and real samples - to help decide sample filter")
plotlist2<-plot.negs.vs.taxa(taxatab = all.taxatabs.ss,ms_ss = ms_ss,real = real)

for(i in 1:length(plotlist2)){
  print(plotlist2[[i]])
}
```

## remove contaminants from relevant groups
```{r, eval=TRUE,echo=F}

#use.contamination.filter function?
if(use.contamination.filter==T){

  if(is.null(negatives)) {
    message("No negatives with reads, skipping contaminant filter")
    } else {
  
      message("Applying contaminant filter")
      group.codes2<-list()
      for(i in 1:length(negatives)){
      group.codes2[[i]]<-neg.groups[match(names(negatives)[i],neg.types)]
      }
      group.codes2<-do.call(c,group.codes2)
      
      all.taxatabs.ss<-remove.contaminant.taxa(taxatab = all.taxatabs.ss,master_sheet = ms_ss,negatives = negatives,group.codes = group.codes2,remove.entire.dataset = remove.entire.dataset)
      
      #check negatives again, just to be sure
      message("Checking that all negatives are now clean")
      
      negatives<-negs.stats(taxatab=all.taxatabs.ss,ms_ss = ms_ss,real=real,ex_hominidae=F)
      
      stepcounter<-stepcounter+1
      all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "rm.contaminants")
  } 
} else {
  message("use.contamination.filter set to FALSE, skipping contaminant filter")
}
```

## remove detection in less than 2 reps 
### PCR negatives are exempt, if the negative option is set (only makes sense pre-rm.contaminants function, or without rm.contaminants function)
```{r, eval=TRUE,echo=F}
all.taxatabs.ss<-rm.single.rep.dxn(taxatab = all.taxatabs.ss,ms_ss = ms_ss,grouping = rep.rm)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "repfilter")
```

## sum reps
```{r, eval=TRUE,echo=F}
all.taxatabs.ss<-sumreps(taxatab = all.taxatabs.ss,ms_ss = ms_ss,grouping = sumrepsby,discard = T)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "sumreps")
```
## apply 2nd detection filter (possibly makes more sense here?)
```{r, eval=TRUE,echo=F}
#check with removing detections
message("Applying detection filter")
all.taxatabs.ss<-filter.dxns(taxatab = all.taxatabs.ss,filter_dxn = filter_dxn2)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "dxnfilter2")
```

## aggregate at chosen level and keep only that-level taxa 
```{r, eval=TRUE,echo=F}
if(is.null(xLevel)) {
  message("Skipping aggregate of taxa at xLevel")
  
  stepcounter<-stepcounter+1
  all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "aggregate_by_xLevel") 
  
} else {
  all.taxatabs.ss<-aggregate.at.xLevel(taxatab=all.taxatabs.ss,xLevel = xLevel)
  stepcounter<-stepcounter+1
  all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "aggregate_by_xLevel") 
  
  all.taxatabs.ss<-keep.below.xLevel.assigns(taxatab = all.taxatabs.ss,xLevel = xLevel)
  
  stepcounter<-stepcounter+1
  all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "keep_only_xLevel") 
}
```
                                                        

## remove unwanted taxa for analysis
```{r, eval=TRUE,echo=F}
message("Removing unwanted taxa")
all.taxatabs.ss<-rm.taxa(taxatab = all.taxatabs.ss,taxa = unwantedTaxa)

stepcounter<-stepcounter+1
all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "unwanted")
```

## summary ---this is pre-grouping - please inspect, add groupings to config file as necessary and look at post-grouping table. Can more grouping be done, is anything wrong?
```{r, eval=TRUE,echo=F}
if(is.null(taxa.to.group)){
  message("Skipping grouping of taxa")
} else {
DT::datatable(summary.dxns.by.taxon(all.taxatabs.ss), rownames = FALSE, options = list(pageLength = 50, scrollX=T))
}
```

## group taxa, where possible
```{r, eval=TRUE}
if(is.null(taxa.to.group)){
  message("Skipping grouping of taxa")
} else {
  
  for(i in 1:nrow(taxa.to.group)){
    all.taxatabs.ss<-bas.group.taxa(taxatab = all.taxatabs.ss,taxon=as.character(taxa.to.group[i,1]), jointo=as.character(taxa.to.group[i,2]))
  }
  
  stepcounter<-stepcounter+1
  all.stats[[stepcounter]]<-taxatab.sumStats(all.taxatabs.ss,stepname = "group_taxa")
}
```

## summary--post-grouping
```{r, eval=TRUE,echo=F}
if(is.null(taxa.to.group)){
  message("Skipping grouping of taxa")
} else {
DT::datatable(summary.dxns.by.taxon(all.taxatabs.ss), rownames = FALSE, options = list(pageLength = 50, scrollX=T))
}
```

## some barplots
```{r, eval=TRUE,echo=F}
message("Making barplots")
plotlist<-list()
for(i in 1:length(plotting.vars)){
plotlist[[i]]<-taxatab.stackplot(taxatab = all.taxatabs.ss,master_sheet = ms_ss,column = plotting.vars[i],as.percent = F,as.dxns = T,hidelegend = T,grouping = sumrepsby)
print(plotlist[[i]][[1]])
print(plotlist[[i]][[2]])
}

for(i in 1:length(plotting.vars)){
plotlist[[i]]<-taxatab.stackplot(all.taxatabs.ss,master_sheet = ms_ss,column = plotting.vars[i],as.percent = T,as.dxns = F,hidelegend = T,grouping = sumrepsby)
print(plotlist[[i]][[1]])
print(plotlist[[i]][[2]])
}

for(i in 1:length(plotting.vars)){
plotlist[[i]]<-taxatab.stackplot(all.taxatabs.ss,master_sheet = ms_ss,column = plotting.vars[i],as.percent = F,as.dxns = F,hidelegend = T,grouping = sumrepsby)
print(plotlist[[i]][[1]])
print(plotlist[[i]][[2]])
}

```


## pca plot (just an example, not interesting in this case)
```{r, eval=TRUE,echo=F}
#just an example, not interesting in this case
message("Plotting pca plot with lines")
for(i in 1:length(plotting.vars)){
  p<-taxatab.pca.plot.col(taxatab = all.taxatabs.ss,ms_ss = ms_ss,grouping = sumrepsby,lines = T,longnames = F,shortnames = T,ellipse = T,factor1 = plotting.vars[i])
  print(p)
}

message("Plotting pca plot without lines")
for(i in 1:length(plotting.vars)){
  p<-taxatab.pca.plot.col(taxatab = all.taxatabs.ss,ms_ss = ms_ss,grouping = sumrepsby,lines = F,longnames = F,shortnames = T,ellipse = T,factor1 = plotting.vars[i])
  print(p)
}
```

## combine counts and taxalists
```{r, eval=TRUE,echo=F}
#counts
message("Note that detections/samples after sumreps will be fewer because reps are joined")

all.counts<-do.call(rbind,lapply(all.stats, `[[`, 1))
all.counts$step<-"not_assigned"
for(i in 1:length(all.stats)){
  all.counts$step[i]<-names(all.stats[[i]])[1]  
}
all.counts$step<-gsub("_counts","",all.counts$step)

print(all.counts)

#taxalists
message("The taxalist output needs more work, depends on collapsed taxa, need to split nto 2 tables, pre and post collapse.
        Running pre-aggregate_by_xLevel only. Some clever way to plot this?")

taxaSteps<-data.frame(start=all.stats[[1]][2][[1]])

#pre-collapse
namesSteps<-"names"
for(i in 1:length(all.stats)){
  namesSteps[i]<-names(all.stats[[i]])[2]  
}

taxaSteps2<-taxaSteps
for(i in 2:(grep("aggregate_by_xLevel_taxa",namesSteps)-1)){
  taxaSteps2<-merge(taxaSteps2, all.stats[[i]][2][[1]],by.x = "start.taxon",by.y = "taxon",all.x = T)
  colnames(taxaSteps2)[length(colnames(taxaSteps2))]<-namesSteps[i]
}

DT::datatable(taxaSteps2, rownames = FALSE, options = list(pageLength = 10, scrollX=T,scrollY=T,fixedColumns = list(leftColumns = 2, rightColumns = 0)),extensions = c('FixedColumns'))

```

## final taxa list
```{r, eval=TRUE,echo=F}
print(all.taxatabs.ss$taxon)
```

## plot counts
```{r, eval=TRUE,echo=F}
message("Note that detections/samples after sumreps will be fewer because reps are joined")

all.counts$step <- factor(all.counts$step,levels = all.counts$step)

stepPlot<-function(all.counts,type="reads"){
  ggplot(all.counts,aes(x=step,y=all.counts[,type],label = all.counts[,type]))+geom_bar(stat = "identity") +
   theme(axis.text.x = element_text(angle = 45,hjust=1))+
   theme(axis.line = element_line(colour = "black"))+
   theme(panel.background = element_blank())+
   theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
   scale_y_continuous(labels = scales::comma)+
   ylab(type)
}

stepPlot(all.counts,type="reads")
stepPlot(all.counts,type="detections")
stepPlot(all.counts,type="taxa")
stepPlot(all.counts,type="samples")
```

## a few final sentences would be good 
```{r, eval=TRUE,echo=F}
#e.g. from x ss_sample_id belonging to real, negs etc,...y had detections, reads etc.
```

## write final table
```{r, eval=TRUE,echo=F}
#write.table(all.taxatabs.ss,"all.taxatabs.ss.txt",quote = F, row.names = F,col.names = T,sep = "\t")
```