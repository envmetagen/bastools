---
title: "Plotting barcode gaps from self-blast results"
html_notebook: default
subtitle: ''
classoption: portrait
output: html_document
includes:  
      #in_header: rmarkdownsettings.txt
      extra_dependencies: ["float"]
---

```{r load functions, eval=TRUE, results='hide',echo=F}
knitr::opts_chunk$set(fig.pos = "!H", out.extra = "")
source(paste0(bastoolsDir,"master_functions.R"))
library(ggplot2)
library(tidyverse)
options(httr_oob_default = TRUE)
all.stats<-list()
TaxlevelTestall<-c("F","G","S")

krona_html_db=paste0(outDir,krona_html_db) #(step1)
selfblastout=paste0(outDir,selfblastout) #(step1)
flagged_accessions=paste0(outDir,flagged_accessions) #(step2)
flagged_error_detailed_table=paste0(outDir,flagged_error_detailed_table) #(step2)
corrected_db=paste0(outDir,corrected_db) #(step2, needed for plotting in step 3)
out_html=paste0(outDir,out_html)
metabin_out=paste0(outDir,metabin_out) # .tsv will be added to this root

read.and.format.full.blast<-function(input){
    #read full blast results
    fullblast<-data.table::fread(input,data.table = F)
    
    #remove hyphens sseq
    fullblast$sseq<-gsub("-","",fullblast$sseq)
    
    #need to reduce db size. decided best seq per taxid, but maybe other ways!
    #keep best hit per saccver=22050
    #keep best per saccver, but only those that had >70% pidents=16390, 80%=9483
    #keep best hit per sseq=29796
    #keep best hit per staxid=9419, 
    #if then only keeping unique sseqs->7953 (could then map results back later,but I have not implemented this)
    #keep best hit per species=8765 (think this is not ideal)
    fullblast<-fullblast[order(fullblast$pident,decreasing = T),]
    #fullblast<-fullblast[!duplicated(fullblast$saccver),] #testing with one per saccaver instead of taxid, not much difference
    fullblast<-fullblast[!duplicated(fullblast$saccver),] 
    fullblast<-fullblast[fullblast$pident>80,]
    
    #make new header names with taxids, for building db
    fullblast$seq.name<-paste0(fullblast$saccver," taxid=", fullblast$taxids,"; ")
    
    #change sseq to seq.text, for phylotools
    colnames(fullblast)<-gsub("sseq","seq.text",colnames(fullblast)) 
    
    #add lineages for later
    fullblast<-add.lineage.df(fullblast,ncbiTaxDir)
    fullblast$origpathS<-paste(fullblast$K,fullblast$P,fullblast$C,fullblast$O,fullblast$F,fullblast$G,fullblast$S,sep=";")
    return(fullblast)
  } 
```

## STEP1 SELF BLAST
```{r self blast, eval=TRUE,echo=F}

if("selfblast" %in% steps) {
  
  setwd(outDir)
  
  t1<-Sys.time()
  
  fullblast<-read.and.format.full.blast(input)
  
  #MAKE KRONA OF DB
  x<-data.frame(taxon=unique(fullblast$origpathS),count=1)
  bas.krona.plot(taxatable = x,out = krona_html_db,KronaPath=KronaPath)
  message("krona plot for self-blast database saved to ", getwd(),"/",krona_html_db)
  
  phylotools::dat2fasta(fullblast[,c("seq.name","seq.text")],paste0("tempBLASTDB.fasta"))
  
  #make blastdb using metabinkit
  system2("metabinkit_blastgendb",c("-f","tempBLASTDB.fasta","-o", "tempBLASTDB","-c"),wait = T)
  
  message("straight SELF-BLAST running...")
  
  system2(command = "blastn",
          args=c("-query", "tempBLASTDB.fasta", "-db","tempBLASTDB","-outfmt",
                 "'6 qseqid saccver ssciname evalue staxid pident qcovs'","-evalue",1,"-num_threads", 2, "-max_target_seqs", 
                 50, "-max_hsps",1,"-word_size", 11,"-perc_identity", 50,"-qcov_hsp_perc",98,
                 "-gapopen", 0, "-gapextend", 2, "-reward", 1, "-penalty", -1, "-dust","no", "-out", selfblastout), wait = T)
  
  #hard coded for now, note the "taxids" rather than "staxid", which metabin does not accept
  headers<-paste0("'1i",paste(c("qseqid", "saccver", "ssciname","evalue", "taxids", "pident", "qcovs"),collapse = "\t"),"'")
  
  system2("sed",c("-i", headers, selfblastout),wait = T)
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("self-blast complete in ",t3," mins")
  
} else message("This step was not set to run")

```

## find_db_errors
```{r find_db_errors, eval=TRUE,echo=F, results='hide'}
if("find_db_errors" %in% steps) {
  
  t1<-Sys.time()
  
  setwd(outDir)
  
  #overall should do this at family, genus and species and combine results
  #why. they identify different IDs
  # outcome_f	outcome_g	outcome_s
  # AC167967.6 failed_A	AC167967.6 failed_A	CP011269.1 failed_A
  # AF517590.1 failed_A	AF037177.1 failed_A	CP023696.1 failed_A
  # CP006776.1 failed_A	AF173599.1 failed_A	CP028288.1 failed_A
  # CP020026.1 failed_A	CP006776.1 failed_A	CP032266.1 failed_A
  # CP025422.1 failed_A	CP020563.1 failed_A	CP041230.1 failed_A
  # CP034120.1 failed_A	CP042305.1 failed_A	DQ499016.1 failed_A
  # CP053707.1 failed_A	CP053707.1 failed_A	KF908854.1 failed_A
  # EU477711.1 failed_A	DQ499016.1 failed_A	LK022891.2 failed_A
  # GQ406290.1 failed_A	EF662118.1 failed_A	LR129750.1 failed_A
  # HM124686.1 failed_A	GQ406258.1 failed_A	LR134345.1 failed_A
  # KC429304.1 failed_A	GQ406261.1 failed_A	MK102803.1 failed_A
  # KF369715.1 failed_A	HM124686.1 failed_A	MT217036.1 failed - possible human
  # KF908854.1 failed_A	KF369715.1 failed_A	MT539994.1 failed - possible human
  # KR153533.1 failed_A	KF908854.1 failed_A	CP018627.1 failed_B
  # KX373635.1 failed_A	LR134345.1 failed_A	LR129713.1 failed_B
  # MF490166.1 failed_A	MK685331.1 failed - possible human	LR215065.1 failed_B
  # MF490206.1 failed_A	MT217036.1 failed - possible human	
  # MG665357.1 failed_A	MT434973.1 failed - possible human	
  # MK078120.1 failed_A	MT539994.1 failed - possible human	
  # MK685331.1 failed - possible human	NC_037015.1 failed_A	
  # MT217036.1 failed - possible human	CP031192.1 failed_B	
  # MT434973.1 failed - possible human	KF499262.1 failed_B	
  # MT512617.1 failed_A		
  # MT539994.1 failed_B		
  
  
  allerrorsdf<-list()
  allflagged<-list()
  ax_exflagged<-list()
  for(h in 1:3){
    
    TaxlevelTest<-TaxlevelTestall[h]
    
    message("finding errors in database using taxonlevel ",TaxlevelTest)
  
    #read self-blast results
    ax<-data.table::fread(selfblastout,data.table = F)
    
    #read and format fullblast results
    fullblast<-read.and.format.full.blast(input)
    
    #add origpath
    ax<-merge(ax,fullblast[,c("saccver", "K","P","C","O","F","G","S","seq.text")], by.x = "qseqid", by.y = "saccver",all.x = T,all.y = F)
    
    #limit to taxleveltest
    ax<-ax[ax[,TaxlevelTest]!="unknown",]
    #if TaxlevelTest[i]="S" remove sp.-type entries  ##if always doing this, could do pre-BLAST
    if(TaxlevelTest=="S"){
      message("Removing species with 'sp.', numbers or more than one space")
      if(length(grep(" sp\\.",ax$S,ignore.case = T))>0) ax<-ax[-grep(" sp\\.",ax$S,ignore.case = T),]
      if(length(grep(" .* .*",ax$S,ignore.case = T))>0) ax<-ax[-grep(" .* .*",ax$S,ignore.case = T),]
      if(length(grep("[0-9]",ax$S))>0) ax<-ax[-grep("[0-9]",ax$S),]
    }
    
    #change colnames
    ax$qseq<-ax$seq.text
    ax$seq.text<-NULL
    ax$Ko<-ax$K
    ax$Po<-ax$P
    ax$Co<-ax$C
    ax$Oo<-ax$O
    ax$Fo<-ax$F
    ax$Go<-ax$G
    ax$So<-ax$S
    ax$K<-NULL
    ax$P<-NULL
    ax$C<-NULL
    ax$O<-NULL
    ax$F<-NULL
    ax$G<-NULL
    ax$S<-NULL
    
    #add full origpath
    ax$origpath<-paste(ax$Ko,ax$Po,ax$Co,ax$Oo,ax$Fo,ax$Go,ax$So,sep=";")
    #add hitpath 
    ax<-add.lineage.df(ax,ncbiTaxDir)
    ax$hitpath<-paste(ax$K,ax$P,ax$C,ax$O,ax$F,ax$G,ax$S,sep=";")
    
    #limit to taxleveltest
    ax<-ax[ax[,TaxlevelTest]!="unknown",]
    #if TaxlevelTest[i]="S" remove sp.-type entries  ##if always doing this, could do pre-BLAST
    if(TaxlevelTest=="S"){
      message("Removing species with 'sp.', numbers or more than one space")
      if(length(grep(" sp\\.",ax$S,ignore.case = T))>0) ax<-ax[-grep(" sp\\.",ax$S,ignore.case = T),]
      if(length(grep(" .* .*",ax$S,ignore.case = T))>0) ax<-ax[-grep(" .* .*",ax$S,ignore.case = T),]
      if(length(grep("[0-9]",ax$S))>0) ax<-ax[-grep("[0-9]",ax$S),]
    }
    
    #order
    ax<-ax[order(ax$qseqid,ax$pident,decreasing = T),]
     
    #add paths of taxleveltest
    ax$origtaxleveltest<-path.at.level(ax$origpath,TaxlevelTest)
    ax$hitleveltest<-path.at.level(ax$hitpath,TaxlevelTest)
    
    #remove potential erroroneous seqs. 
    #where, apart from itself, all hits above threshold(?) (80%) belong to different families. 
    #e.g ax[ax$qseqid=="KC429304.1",] (item 5003) KC429304.1 (5193)
    #AND the different families have at least one high hit e.g. >98%
    #AND it did not have hits to other sequences of its own family 
    #AND the other hits belong to only one family...necessary? not being implemeneted
    #AND there are other members of the family in the database
    
    #remove errors after each loop, otherwise some are missed (e.g.s)
    # qseqid	real	designated	flagged by script
    # MT539994.1	human	Eukaryota;Arthropoda;Insecta;Hymenoptera;Formicidae	y ref 8710
    # MK685331.1	human	Eukaryota;Arthropoda;Arachnida;Araneae;Lycosidae	No, because of MT434973.1 ref8435
    # MT217036.1	human	Eukaryota;Chordata;Lepidosauria;Squamata;Gekkonidae	No, because of MK685331.2 ref 8679
    # MT434973.1	human	Eukaryota;Arthropoda;Arachnida;Araneae;Hahniidae	No, because of MK685331.1 ref 8685
    #looping didnt solve this. added a human-specific test
    
    
    ax.list<-split(ax,ax$qseqid)
    errors<-list()
    for(i in 1:length(ax.list)){
      
        # if(ax.list[[i]]$qseqid[1]=="KX550091.1") stop(i)
        # }
       # 
      #remove self-hit
      outcome<-"failed"
      
      xx<-ax.list[[i]][ax.list[[i]]$saccver!=ax.list[[i]]$qseqid[1],]
      
      if(nrow(xx)==0) outcome<-"passed"
      
      #use a threshold here. i.e. of the remaning hits, keep only >80%
      xx<-xx[xx$pident>=80,]
      
      if(nrow(xx)==0) outcome<-"passed"
      
      #human test
      #hutaxleveltest<-path.at.level("Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens",TaxlevelTest)
      if(outcome=="failed") if("Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens" %in% xx$hitpath) {
        if(max(xx[xx$hitpath=="Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens","pident"])>98) outcome<-"human"
      }
      
      #all other hits belong to other families only, and do not include original family
      if(outcome=="failed") if(xx$origtaxleveltest[1] %in% xx$hitleveltest) outcome<-"passed"
        
      #remaining families contain a high hit (e.g. 98%)
      if(outcome=="failed" | outcome=="human") if(max(xx$pident)<98) outcome<-"passed"
          
      #database contains other representatives of this family?
      ###TODO this should probably use error-free database?
      if(outcome=="failed") if(length(unique(ax[ax$origtaxleveltest==xx$origtaxleveltest[1],"qseqid"]))==1) outcome<-"passed"
        
      if(outcome=="failed" | outcome=="human") {
        errors[[i]]<-ax.list[[i]]
        current<-ax.list[[i]]$qseqid[1]
        if(outcome=="failed") {
          message(current," failed_A")
          errors[[i]]$reason<-"filterA"
        }
        if(outcome=="human") {
          message(current," failed - possible human")
          errors[[i]]$reason<-"filterHu"
        }
        #remove from db before next loop
        ax.list<-lapply(ax.list, function(x) x[x$saccver!=current,]) 
        #message("ever works?")
      } else errors[[i]]<-NULL
    }
    
    #these settings are identifying likely errors, cool, but not finding KC429304.1
    # passes filter because it has hits above 80% to mainly one family, but also another family.
    #now working!
    
    errors2<-errors %>% discard(is.null)
    if(length(errors2)>0) {
      errors3<-do.call(rbind,errors2)
      errorstemp<-errors3[,c("qseqid","saccver" ,"pident","origtaxleveltest","hitleveltest","reason","qseq")]
      flagged<-unique(errors3$qseqid)
    } else {
      errorstemp<-NULL
      flagged<-NULL
    }
    
    
    #second filter based on hits. if all hits from an entry are NEVER the same as the origpath, likely an error
    #AND there were high hits
    #AND there other members of the taxonlevel in the database
    
    ax2<-do.call(rbind,ax.list)
    ax.list2<-split(ax2,ax2$saccver)
    error.filter2<-list()
    for(i in 1:length(ax.list2)){
      outcome<-"failed"
    
      current<-unique(ax.list2[[i]]$saccver)[1]
      currenttax<-ax.list2[[i]]$hitleveltest[1]
    
      #were there other members of the family in the database
      if(length(unique(ax2[ax2$origtaxleveltest==currenttax,"qseqid"]))==1) outcome<-"passed"
    
      if(outcome=="failed"){
      
        yy<-ax.list2[[i]][ax.list2[[i]]$saccver==current,]
        yy<-yy[yy$qseqid!=current,]
       
        #if all hits from an entry are NEVER the same as the origpath, if there were high hits
        if(nrow(yy)>0) if(!yy$hitleveltest[1] %in% yy$origtaxleveltest) if(max(yy$pident)>98) {
          error.filter2[[i]]<-yy 
          message(current," failed_B")
          error.filter2[[i]]$reason<-"filterB"
        } else error.filter2[[i]]<-NULL
      } else error.filter2[[i]]<-NULL
    }
    
    #h
       
    error.filter2<-error.filter2 %>% discard(is.null)
    if(length(error.filter2)>0) {
      error.filter2df<-do.call(rbind,error.filter2)
      error.filter2df<-error.filter2df[order(error.filter2df$saccver,error.filter2df$pident,decreasing = T),]
      error.filter2df<-error.filter2df[,c("qseqid","saccver" ,"pident","origtaxleveltest","hitleveltest","reason","qseq")]
      flagged2<-unique(error.filter2df$saccver)
    } else   {
      flagged2<-NULL
      error.filter2df<-NULL
    }
    
    #combine filter results within h loop
    allerrorsdf[[h]]<-rbind(errorstemp,error.filter2df)
    allerrorsdf[[h]]$taxlevel<-TaxlevelTestall[h]
    allflagged[[h]]<-c(flagged, flagged2)
  } #h
  
  #combine results for all taxon loops
  allerrorsdf<-do.call(rbind,allerrorsdf) #note that some qseqids will be repeated (different taxlevels)
  
  allflagged<-do.call(c,allflagged)
  allflagged<-unique(allflagged)
  ax_exflagged<-ax[!ax$qseqid %in% allflagged,]
  ax_exflagged<-ax_exflagged[!ax_exflagged$saccver %in% allflagged,]
  
  write.table(allflagged,flagged_accessions,row.names = F,quote = F,sep = "\t")
  write.table(allerrorsdf,file = flagged_error_detailed_table,quote = F,sep = "\t",row.names = F)
  write.table(ax_exflagged,file = corrected_db,quote = F,sep = "\t",row.names = F)
  
  #tables not printing!
  message("flagged accession numbers")
  print(allflagged)
  
  message("flagged accession detailed results - inspect carefully")
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("finding errors complete in ",t3," mins")

  DT::datatable(allerrorsdf, rownames = FALSE, options = list(pageLength = 50, scrollX=T),
                caption = "flagged accession detailed results - inspect carefully")
  #note:DT only working inside this if statement because it is the last thing in the statement
  
  
} else message("This step was not set to run")
```

# calc_bar_gap
```{r plots, eval=TRUE,echo=F,fig.height=7,fig.width=10}
 #STEP3 calculate barcoding gaps
if("calc_bar_gap" %in% steps) {
  
  t1<-Sys.time()
  
  message("Limiting plots to ",plot.limit.taxon)
  
  ax_exflagged<-data.table::fread(corrected_db,data.table=F)  
  plot.list.loop<-list()
  plot.list.all<-list()
  perc_among_res<-list()
  for(h in 1:3){
    
    TaxlevelTest<-TaxlevelTestall[h]
    
    #message("TaxlevelTest: ",TaxlevelTest)
    
    ax_exflagged$origtaxleveltest<-path.at.level(ax_exflagged$origpath,TaxlevelTest)
    ax_exflagged$hitleveltest<-path.at.level(ax_exflagged$hitpath,TaxlevelTest)

    #within taxlevel vs among tax level range
    newtab<-data.frame(matrix(ncol=5,nrow = length(unique(ax_exflagged$origtaxleveltest))))
    colnames(newtab)<-c("taxon","max_within","min_within","max_among","min_among")
    
    
    ax_exflagged.spl<-split(ax_exflagged,ax_exflagged$origtaxleveltest)
    
    for(i in 1:length(ax_exflagged.spl)){
      temp<-ax_exflagged.spl[[i]]
      taxoni<-temp$origtaxleveltest[1]
      newtab$taxon[i]=taxoni
      newtab$max_within[i]=max(temp[temp$hitleveltest==taxoni,"pident"])
      newtab$min_within[i]=min(temp[temp$hitleveltest==taxoni,"pident"])
      
      if(nrow(temp[temp$hitleveltest!=taxoni,])>0){
        newtab$max_among[i]=max(temp[temp$hitleveltest!=taxoni,"pident"])
        newtab$min_among[i]=min(temp[temp$hitleveltest!=taxoni,"pident"])
      } else {
        newtab$max_among[i]=0
        newtab$min_among[i]=0
      }
    }
    
    #plot
    newtablong<-reshape2::melt(newtab,id.vars="taxon")
    
    #plot limit
    if(!is.null(plot.limit.taxon)) newtablong<-newtablong[grep(plot.limit.taxon,newtablong$taxon),]
     
    newtablong$groups<-""
    newtablong$groups[newtablong$variable=="max_within" | newtablong$variable=="min_within"]<-paste("within",TaxlevelTest,"range")
    newtablong$groups[newtablong$variable=="max_among" | newtablong$variable=="min_among"]<-paste("among",TaxlevelTest,"range")
    
    plota<-ggplot(newtablong,aes(x = taxon,y = value,colour=groups,group=interaction(taxon,groups)))+geom_point()+
      theme(axis.text.x=element_text(size=8,angle=45, hjust=1),legend.title = element_blank(),
            panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.background = element_blank(),
            axis.line = element_line(colour = "black"))+
      geom_line()+ylab("Percentage identity")+xlab("")
    
    #counts. 
    values<-seq(100,50,-1)
    res<-data.frame(pident=values,nTaxaWithin=0,nTaxaAmong=0)
    for(i in 1:length(values)){
      xx<-newtablong[newtablong$value>=values[i],]
      res[i,"nTaxaWithin"]<-length(unique(xx[grep("within",xx$groups),"taxon"])) #because newtabalong has two values for each taxon
      res[i,"nTaxaAmong"]<-length(unique(xx[grep("among",xx$groups),"taxon"]))
    }
    
    #plot res
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt$nTaxa<-resmelt$value
    
    plotb<-ggplot(resmelt,aes(x = pident,y = nTaxa,colour=variable))+geom_point()
      
    res$percent_among<-res$nTaxaAmong/res$nTaxaWithin*100
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt<-resmelt[resmelt$variable=="percent_among",]
    resmelt$percent_among<-resmelt$value
    
    plotc<-ggplot(resmelt,aes(x = pident,y = percent_among))+geom_point()
    
    #table of perc_within
    resx<-res[res$pident %in% c(100,99,98,97,96,95,90,85,80,75,70,65,60,50),]
    resx$percent_among<-round(resx$percent_among,digits = 0)
    perc_among_res[[h]]<-resx
    
    plot.list.loop[[1]]<-plota
    plot.list.loop[[2]]<-plotb
    plot.list.loop[[3]]<-plotc
    plot.list.all[[h]]<-plot.list.loop
    
    # #table of tops (diff)
    # newtab$diff<-newtab$min_within-newtab$max_among
    # #plot limit
    # if(!is.null(plot.limit.taxon)) newtab<-newtab[grep(plot.limit.taxon,newtab$taxon),]
    # ##change diff to zero if negative
    # newtab$diff[newtab$diff<0]<-0
    # 
    # diffs<-newtab[newtab$diff %in% c(100,95,90,85,80,75,70,65,60,50),]
    # resx$percent_among<-round(resx$percent_among,digits = 0)
    # perc_among_res[[h]]<-resx
    # 
    # ggplot(newtab,aes(x = taxon,y = diff))+geom_point()+
    #   theme(axis.text.x=element_text(size=8,angle=45, hjust=1),legend.title = element_blank(),
    #         panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.background = element_blank(),
    #         axis.line = element_line(colour = "black"))
    
  }
  
  for(h in 1:3){
    print(plot.list.all[[h]][[1]])  
    print(plot.list.all[[h]][[2]])  
    print(plot.list.all[[h]][[3]])  
  }
  
  message("Family level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[1]])
  message("Genus level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[2]])
  message("Species level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[3]])
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("calculating barcode gaps in ",t3," mins")
  
} else message("This step was not set to run")
    
```

# metabin
```{r metabin, eval=TRUE,echo=F,fig.height=7,fig.width=10}
 #STEP4 metabin
#what to do here? loop tops? loop blast?
#already found pidents. Just tops remaining
#use flagged accessions?
if("metabin" %in% steps){
  
  setwd(outDir)
  
  t1<-Sys.time()
  
  tops<-c(0,1,2,5,10,100)
  outfiles<-""
  l=0
  for(j in 1:length(tops)){
        l=l+1
        
        outfiles[l]<-paste0(metabin_out,"_top",tops[j])
        if(use_flagged_accessions){
        system2("metabin",c("-i",input, "-o",outfiles[l], "--FilterFile",flagged_accessions, "--FilterCol","saccver", "-S", 98,"-G", 95
                         ,"-F", 85,"-A", 70, "--TopSpecies", tops[j],"--TopGenus",
                         tops[j],"--TopFamily", tops[j]
                         ,"--TopAF", 100,"--no_mbk"),wait=T)
        } else {
          system2("metabin",c("-i",input, "-o",outfiles[l], "-S", 98,"-G", 95
                         ,"-F", 85,"-A", 70, "--TopSpecies", tops[j],"--TopGenus",
                         tops[j],"--TopFamily", tops[j]
                         ,"--TopAF", 100,"--no_mbk"),wait=T)
        }
  }
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("metabin complete in ",t3," mins")
} else message("This step was not set to run")

```
