---
title: "Plotting barcode gaps from self-blast results"
html_notebook: default
subtitle: ''
classoption: portrait
output: html_document
includes:  
      #in_header: rmarkdownsettings.txt
      extra_dependencies: ["float"]
---
# Prerequisites. The input is the results of a "thorough" blast against a large database, ideally nt
## e.g. blastn -query my.fasta -db nt -outfmt '6 qseqid saccver staxid pident sseq' -evalue 1 -max_target_seqs 50 -max_hsps 1 -word_size 11 -perc_identity 50 -qcov_hsp_perc 98 -gapopen 0 -gapextend 2 -reward 1 -penalty -1 -dust no -out my.blast.tsv
## In any case I recommend such settings, although it takes longer, as they are much more informative and useful for metabarcoding.
```{r load functions, eval=TRUE, results='hide',echo=F}
knitr::opts_chunk$set(fig.pos = "!H", out.extra = "")
source(paste0(bastoolsDir,"master_functions.R"))
library(ggplot2)
library(tidyverse)
options(httr_oob_default = TRUE)
all.stats<-list()
TaxlevelTestall<-c("F","G","S")

read.and.format.full.blast<-function(input,minpident=80){
  
  output<-list()
  
    #read full blast results
    fullblast<-data.table::fread(input,data.table = F)
    
    fullblast<-data.table::fread(input,data.table=F,
  select = c("qseqid","saccver","taxids","pident","sseq") )
    
    #remove hyphens sseq
    fullblast$sseq<-gsub("-","",fullblast$sseq)
    
    #need to reduce db size. not sure of best option!
    ##currently- for fasta using the saccver that had the best hit in original blast and disregarding saccvers whose best hit was below 80%. i.e. those with best hit below 80% will just not be tested #9458
    #for database using the same
    
    #keep best hit per saccver=22050
    #keep best per saccver, but only those that had >70% pidents=16390, 80%=9483
    #keep best hit per sseq=29796
    #keep best hit per staxid=9419, 
    #if then only keeping unique sseqs->7953 (could then map results back later,but I have not implemented this)
    #keep best hit per species=8765 (think this is not ideal)
    fullblast<-fullblast[order(fullblast$pident,decreasing = T),]
    #fullblast<-fullblast[!duplicated(fullblast$saccver),] 
    #testing with one per saccaver instead of taxid, not much difference. actually led toincorrect flags, because sometimes there are so many of one taxon that the blast does not find the original taxon
    fullblast<-fullblast[!duplicated(fullblast$saccver),] #too many seqs
    fullblast<-fullblast[fullblast$pident>minpident,] #is this dodgy? 
    
    #limit to max 50 per taxid to overcome the "thunnus issue"
    fullblast_spl<-split(fullblast,fullblast$taxids)
    for(i in 1:length(fullblast_spl)){
      if(nrow(fullblast_spl[[i]])>50) fullblast_spl[[i]]<-fullblast_spl[[i]][1:50,]
    }
    
    fullblast<-do.call(rbind,fullblast_spl)
    
    
    #make new header names with taxids, for building db
    fullblast$seq.name<-paste0(fullblast$saccver," taxid=", fullblast$taxids,"; ")
    
    #change sseq to seq.text, for phylotools
    colnames(fullblast)<-gsub("sseq","seq.text",colnames(fullblast)) 
    
    #add lineages for later
    fullblast<-add.lineage.df(fullblast,ncbiTaxDir)
    fullblast$origpathS<-paste(fullblast$K,fullblast$P,fullblast$C,fullblast$O,fullblast$F,fullblast$G,fullblast$S,sep=";")
    
    ##other options
    #1. a full database, i.e. best seq for each saccevr (22k), the same query as already. Maybe not much slower, and can still find errors,
    #with filterB, but not as many I guess
    
    
    # #keep multiple human, e.g 100
    # fullblastdbh<-fullblast[fullblast$origpathS=="Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens",]
    # if(nrow(fullblastdbh)>100) fullblastdbh<-fullblastdbh[1:100,]
    # fullblastdbexh<-fullblast[fullblast$origpathS!="Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens",]
    # 
    # fullblastdbexh<-fullblastdbexh[!duplicated(fullblastdbexh$taxids),] #3232+606 extra human
    # fullblastdb<-rbind(fullblastdbexh,fullblastdbh)
    # 
    # rm(fullblastdbh)
    # rm(fullblastdbexh)
    # 
    # output[[1]]<-fullblast  #the fasta of all saccvers above 80%
    # output[[2]]<-fullblastdb #the database of only taxids #not working, incorrectly assigned errors
    
    return(fullblast)
  } 
```

## STEP1 SELF BLAST
### Convert the sseqs into a blast database, select all saccvers that had >80% identity. Output a krona plot of the database, to see what is in it
```{r self blast, eval=TRUE,echo=F}

if("selfblast" %in% steps) {
  
  t1<-Sys.time()
  
  fullblast<-read.and.format.full.blast(input) 
  
  #remove known flags
  if(!is.null(known_flags)) {
    kf<-data.table::fread(known_flags,data.table = F,header = F)
    fullblast<-fullblast[!fullblast$qseqid %in% kf$V1,]
    fullblast<-fullblast[!fullblast$saccver %in% kf$V1,]
  }
  
  #MAKE KRONA OF DB
  x<-as.data.frame(table(fullblast$origpathS))
  colnames(x)<-c("taxon","count")
  #x<-data.frame(taxon=fullblast$origpathS,count=1)
  bas.krona.plot(taxatable = x,out = paste0(outDir,krona_html_db),KronaPath = KronaPath)
  
  #use the max count for a given taxon as the max blast hits, otherwise some hits will be erroneously flagged
  #e.g. 
# thunnus	AB097669.1	so many seqs in this genus, that this one is not in top 100
# thunnus	GQ461734.1	so many seqs in this genus, that this one is not in top 100
# thunnus	AY958655.1	so many seqs in this genus, that this one is not in top 100

  #mx_targets<-max(x$count)
  #files just got too big for R, limited now to 150
  
  message("krona plot for self-blast database saved to ", paste0(outDir,krona_html_db))
  
  phylotools::dat2fasta(fullblast[,c("seq.name","seq.text")],paste0(outDir,"tempBLASTDB.fasta"))
  #phylotools::dat2fasta(fullblast[[1]][,c("seq.name","seq.text")],paste0("tempBLASTquery.fasta"))
  
  #make blastdb using metabinkit
  system2("metabinkit_blastgendb",c("-f",paste0(outDir,"tempBLASTDB.fasta"),"-o", paste0(outDir,"tempBLASTDB"),"-c"),wait = T)
  
  message("straight SELF-BLAST running...")
  
  #dealing with variable lengths of sseq sequences.
   #need to relax -qcov because the sseqs produced from first blast may be variable, some may be a bit short, therefore wouldnt have hits on self-blast, if "-qcov_hsp_perc=98, leads to incorrectly flagged seqs!
  
  #min_qcovtemp<-round(min(nchar(fullblast$seq.text))/max(nchar(fullblast$seq.text))*100,digits = 0)
  
  #decided to add as a check later instead
  
  rm(fullblast)
  
  system2(command = "blastn",
          args=c("-query", paste0(outDir,"tempBLASTDB.fasta"), "-db",paste0(outDir,"tempBLASTDB"),"-outfmt",
                 "'6 qseqid saccver staxid pident qcovs'","-evalue",1,"-num_threads", 64, "-max_target_seqs", 
                 100, "-max_hsps",1,"-word_size", 11,"-perc_identity", 70,"-qcov_hsp_perc",98,
                 "-gapopen", 0, "-gapextend", 2, "-reward", 1, "-penalty", -1, "-dust","no", "-out", 
                 paste0(outDir,selfblastout)), wait = T)
  
  
  #hard coded for now, note the "taxids" rather than "staxid", which metabin does not accept
  headers<-paste0("'1i",paste(c("qseqid", "saccver", "taxids", "pident", "qcovs"),collapse = "\t"),"'")
  
  system2("sed",c("-i", headers, paste0(outDir,selfblastout)),wait = T)
  
  #remove tempdb
  file.remove(list.files(pattern = "tempBLASTDB.n.*"))
  file.remove("tempBLASTDB.fasta")
  file.remove("tempBLASTDB.taxid_map.tsv")
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("self-blast complete in ",t3," mins")
  
} else message("This step was not set to run")

```

## find_db_errors
### For each taxonomic level (F,G,S) look for potentially misassigned entries (see output for rules). Output a table of the results for manual inspection
### So far haven seen any flagged accessions that seem incorrectly flagged. But not all errors are caught. Main case is when there are multiple erroneously labelled entries of the same taxon. 
```{r find_db_errors, eval=TRUE,echo=F}
if("find_db_errors" %in% steps) {

  t1<-Sys.time()

  message("using min representaives=3")
    
  #setwd(outDir)
  
  #overall should do this at family, genus and species and combine results
  #why. they identify different IDs
  # outcome_f	outcome_g	outcome_s
  # AC167967.6 failed_A	AC167967.6 failed_A	CP011269.1 failed_A
  # AF517590.1 failed_A	AF037177.1 failed_A	CP023696.1 failed_A
  # CP006776.1 failed_A	AF173599.1 failed_A	CP028288.1 failed_A
  # CP020026.1 failed_A	CP006776.1 failed_A	CP032266.1 failed_A
  # CP025422.1 failed_A	CP020563.1 failed_A	CP041230.1 failed_A
  # CP034120.1 failed_A	CP042305.1 failed_A	DQ499016.1 failed_A
  # CP053707.1 failed_A	CP053707.1 failed_A	KF908854.1 failed_A
  # EU477711.1 failed_A	DQ499016.1 failed_A	LK022891.2 failed_A
  # GQ406290.1 failed_A	EF662118.1 failed_A	LR129750.1 failed_A
  # HM124686.1 failed_A	GQ406258.1 failed_A	LR134345.1 failed_A
  # KC429304.1 failed_A	GQ406261.1 failed_A	MK102803.1 failed_A
  # KF369715.1 failed_A	HM124686.1 failed_A	MT217036.1 failed - possible human
  # KF908854.1 failed_A	KF369715.1 failed_A	MT539994.1 failed - possible human
  # KR153533.1 failed_A	KF908854.1 failed_A	CP018627.1 failed_B
  # KX373635.1 failed_A	LR134345.1 failed_A	LR129713.1 failed_B
  # MF490166.1 failed_A	MK685331.1 failed - possible human	LR215065.1 failed_B
  # MF490206.1 failed_A	MT217036.1 failed - possible human	
  # MG665357.1 failed_A	MT434973.1 failed - possible human	
  # MK078120.1 failed_A	MT539994.1 failed - possible human	
  # MK685331.1 failed - possible human	NC_037015.1 failed_A	
  # MT217036.1 failed - possible human	CP031192.1 failed_B	
  # MT434973.1 failed - possible human	KF499262.1 failed_B	
  # MT512617.1 failed_A		
  # MT539994.1 failed_B		
  
  
  allerrorsdf<-list()
  allflagged<-list()
  ax_exflagged<-list()
  
  #read and format fullblast results
  fullblast<-read.and.format.full.blast(input)
  
  #read self-blast results
  ax1<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
    
  #add origpath
  ax1<-merge(ax1,fullblast[,c("saccver", "K","P","C","O","F","G","S","seq.text")], by.x = "qseqid", by.y = "saccver",all.x = T,all.y = F)
  
  #remove known flags
  if(!is.null(known_flags)) {
    kf<-data.table::fread(known_flags,data.table = F,header = F)
    ax1<-ax1[!ax1$qseqid %in% kf$V1,]
    ax1<-ax1[!ax1$saccver %in% kf$V1,]
  }
  
  rm(fullblast)
  
  for(h in 1:3){
    
    TaxlevelTest<-TaxlevelTestall[h]
    
    message("finding errors in database using taxonlevel ",TaxlevelTest)
  
    #limit to taxleveltest not unknown
    ax<-ax1[ax1[,TaxlevelTest]!="unknown",]
    
    #if TaxlevelTest[i]="S" remove sp.-type entries  ##if always doing this, could do pre-BLAST
    if(TaxlevelTest=="S"){
      message("Removing species with 'sp.', numbers or more than one space")
      if(length(grep(" sp\\.",ax$S,ignore.case = T))>0) ax<-ax[-grep(" sp\\.",ax$S,ignore.case = T),]
      if(length(grep(" .* .*",ax$S,ignore.case = T))>0) ax<-ax[-grep(" .* .*",ax$S,ignore.case = T),]
      if(length(grep("[0-9]",ax$S))>0) ax<-ax[-grep("[0-9]",ax$S),]
      
      #remove crappy hits 
 
    #1. btab$S contains uncultured
    message("Removing species containing the terms: uncultured, environmental, 
            unidentified,fungal, eukaryote or unclassified")
    if(length(grep("uncultured",ax$S,ignore.case = T))>0) ax<-ax[-grep("uncultured",ax$S,ignore.case = T),]
    if(length(grep("environmental",ax$S,ignore.case = T))>0) ax<-ax[-grep("environmental",ax$S,ignore.case = T),]
    if(length(grep("unclassified",ax$S,ignore.case = T))>0) ax<-ax[-grep("unclassified",ax$S,ignore.case = T),]
    if(length(grep("unidentified",ax$S,ignore.case = T))>0) ax<-ax[-grep("unidentified",ax$S,ignore.case = T),]
    if(length(grep("fungal ",ax$S,ignore.case = T))>0) ax<-ax[-grep("fungal ",ax$S,ignore.case = T),]
    if(length(grep("eukaryote",ax$S,ignore.case = T))>0) ax<-ax[-grep("eukaryote",ax$S,ignore.case = T),]
    if(length(grep("synthetic",ax$S,ignore.case = T))>0) ax<-ax[-grep("synthetic",ax$S,ignore.case = T),]
    }
    
    #change colnames
    ax$qseq<-ax$seq.text
    ax$seq.text<-NULL
    ax$Ko<-ax$K
    ax$Po<-ax$P
    ax$Co<-ax$C
    ax$Oo<-ax$O
    ax$Fo<-ax$F
    ax$Go<-ax$G
    ax$So<-ax$S
    ax$K<-NULL
    ax$P<-NULL
    ax$C<-NULL
    ax$O<-NULL
    ax$F<-NULL
    ax$G<-NULL
    ax$S<-NULL
    
    #add full origpath
    ax$origpath<-paste(ax$Ko,ax$Po,ax$Co,ax$Oo,ax$Fo,ax$Go,ax$So,sep=";")
    #add hitpath 
    ax<-add.lineage.df(ax,ncbiTaxDir)
    ax$hitpath<-paste(ax$K,ax$P,ax$C,ax$O,ax$F,ax$G,ax$S,sep=";")
    
    #limit to taxleveltest
    ax<-ax[ax[,TaxlevelTest]!="unknown",]
    #if TaxlevelTest[i]="S" remove sp.-type entries  ##if always doing this, could do pre-BLAST
    if(TaxlevelTest=="S"){
      message("Removing species with 'sp.', numbers or more than one space")
      if(length(grep(" sp\\.",ax$S,ignore.case = T))>0) ax<-ax[-grep(" sp\\.",ax$S,ignore.case = T),]
      if(length(grep(" .* .*",ax$S,ignore.case = T))>0) ax<-ax[-grep(" .* .*",ax$S,ignore.case = T),]
      if(length(grep("[0-9]",ax$S))>0) ax<-ax[-grep("[0-9]",ax$S),]
      
      #1. btab$S contains uncultured
    message("Removing species containing the terms: uncultured, environmental, 
            unidentified,fungal, eukaryote or unclassified")
    if(length(grep("uncultured",ax$S,ignore.case = T))>0) ax<-ax[-grep("uncultured",ax$S,ignore.case = T),]
    if(length(grep("environmental",ax$S,ignore.case = T))>0) ax<-ax[-grep("environmental",ax$S,ignore.case = T),]
    if(length(grep("unclassified",ax$S,ignore.case = T))>0) ax<-ax[-grep("unclassified",ax$S,ignore.case = T),]
    if(length(grep("unidentified",ax$S,ignore.case = T))>0) ax<-ax[-grep("unidentified",ax$S,ignore.case = T),]
    if(length(grep("fungal ",ax$S,ignore.case = T))>0) ax<-ax[-grep("fungal ",ax$S,ignore.case = T),]
    if(length(grep("eukaryote",ax$S,ignore.case = T))>0) ax<-ax[-grep("eukaryote",ax$S,ignore.case = T),]
    if(length(grep("synthetic",ax$S,ignore.case = T))>0) ax<-ax[-grep("synthetic",ax$S,ignore.case = T),]
    }
    
    #order
    ax<-ax[order(ax$qseqid,ax$pident,decreasing = T),]
     
    #add paths of taxleveltest
    ax$origtaxleveltest<-path.at.level(ax$origpath,TaxlevelTest)
    ax$hitleveltest<-path.at.level(ax$hitpath,TaxlevelTest)
    
    #remove potential erroroneous seqs. 
    #where, apart from itself, all hits above threshold(?) (80%) belong to different families. 
    #e.g ax[ax$qseqid=="KC429304.1",] (item 5003) KC429304.1 (5193)
    #AND the different families have at least one high hit e.g. >98%
    #AND it did not have hits to other sequences of its own family 
    #AND the other hits belong to only one family...necessary? not being implemeneted
    #AND there are other members of the family in the database
    
    #remove errors after each loop, otherwise some are missed (e.g.s)
    # qseqid	real	designated	flagged by script
    # MT539994.1	human	Eukaryota;Arthropoda;Insecta;Hymenoptera;Formicidae	y ref 8710
    # MK685331.1	human	Eukaryota;Arthropoda;Arachnida;Araneae;Lycosidae	No, because of MT434973.1 ref8435
    # MT217036.1	human	Eukaryota;Chordata;Lepidosauria;Squamata;Gekkonidae	No, because of MK685331.2 ref 8679
    # MT434973.1	human	Eukaryota;Arthropoda;Arachnida;Araneae;Hahniidae	No, because of MK685331.1 ref 8685
    #looping didnt solve this. added a human-specific test
    
    ax.list<-split(ax,ax$qseqid)
    
    errors<-list()
    #think I need to save human sequences until the end, otherwise if a human seq fails (and I only have one anyway because of choosing one seq per taxid), because everything else was erroneous, it is removed and then we have lots of other incorrect failures
    #now implemented in read.and.format.full.blast
    
    for(i in 1:length(ax.list)){
      
             #if(ax.list[[i]]$qseqid[1]=="AF508071.1") stop(i)
             #}
      outcome<-"failed"
      
      #remove self-hit
      xx<-ax.list[[i]][ax.list[[i]]$saccver!=ax.list[[i]]$qseqid[1],]
      
      #if no other hits, cannot fail
      if(nrow(xx)==0) outcome<-"passed"
      
      #use a threshold here. i.e. of the remaning hits, keep only >80%
      xx<-xx[xx$pident>=80,]
      
      if(nrow(xx)==0) outcome<-"passed"
      
      #human test
      if(outcome=="failed") {
        #hutaxleveltest<-path.at.level("Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens",TaxlevelTest)
        #still assigns other primates as likely human, skip primates
        if(length(grep("Eukaryota;Chordata;Mammalia;Primates",xx$origtaxleveltest[1]))!=1) {
          if("Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens" %in% xx$hitpath) {
          #using full path here to avoid other Hominidae...(?)
            if(max(xx[xx$hitpath=="Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens","pident"])>98) outcome<-"human"
          }
        }
      }
      
      #all other hits belong to other families only, and do not include original family
      if(outcome=="failed") if(xx$origtaxleveltest[1] %in% xx$hitleveltest) outcome<-"passed"
      
      #remaining families contain a high hit (e.g. 98%)
      if(outcome=="failed" | outcome=="human") if(max(xx$pident)<98) outcome<-"passed"
          
      #if database doesnt contain at least 3 other representatives of the taxon, then pass it. If it does contain 3 other representatives then fail it, but only if other representatives have at least 3 sequences that are within 2% of query length (otherwise they wont be in blast results and can be erroneously flagged)
      if(outcome=="failed") {
        
        if(length(unique(ax[ax$origtaxleveltest==xx$origtaxleveltest[1],"qseqid"]))>3) {
          qlen<-nchar(xx$qseq[1])
          minslen<-round(qlen*0.981,digits = 0) #just adding to one to be sure it is above
          seqs.in.group<-unique(ax[ax$origtaxleveltest==xx$origtaxleveltest[1],c("qseqid", "qseq")]) #will include itself
          seqs.in.group<-seqs.in.group[!seqs.in.group$qseqid==xx$qseqid[1],]
          slens<-nchar(seqs.in.group$qseq)
          slens<-slens[order(slens,decreasing = T)]
          slens<-slens[slens>=minslen]
          
          if(length(slens)<3) outcome<-"passed" 
        
        } else outcome<-"passed"
      }
  
     if(outcome=="failed" | outcome=="human") {
        errors[[i]]<-ax.list[[i]]
        current<-ax.list[[i]]$qseqid[1]
        if(outcome=="failed") {
          message(current," failed_A")
          errors[[i]]$reason<-"filterA"
        }
        if(outcome=="human") {
          message(current," failedHu - possible human")
          errors[[i]]$reason<-"filterHu"
        }
        #remove from db before next loop.  
        ax.list<-lapply(ax.list, function(x) x[x$saccver!=current,]) 
      } else errors[[i]]<-NULL
    } #
    
    
    #these settings are identifying likely errors, cool, but not finding KC429304.1
    # passes filter because there are no other members of this family in the db

    #h
    
    errors2<-errors %>% discard(is.null)
    if(length(errors2)>0) {
      errors3<-do.call(rbind,errors2)
      errorstemp<-errors3[,c("qseqid","saccver" ,"pident","origtaxleveltest","hitleveltest","reason","qseq")]
      flagged<-unique(errors3$qseqid)
    } else {
      errorstemp<-NULL
      flagged<-NULL
    }
    
    #FILTER_B
    #second filter based on hits. if all hits from an entry are NEVER the same as the origpath, likely an error
    #AND there were high hits
    #AND there at least three other members of the taxonlevel in the database
    
    ax2<-do.call(rbind,ax.list)
    ax.list2<-split(ax2,ax2$saccver)
    error.filter2<-list()
    for(i in 1:length(ax.list2)){
      outcome<-"failed"
      
         #if(ax.list2[[i]]$saccver[1]=="KC429304.1") stop(i)
            
    
      current<-unique(ax.list2[[i]]$saccver)[1]
      currenttax<-ax.list2[[i]]$hitleveltest[1]
    
      #were there at least three other members of the family in the database. If not, must pass.
      #if(length(unique(ax2[ax2$origtaxleveltest==currenttax,"qseqid"]))==1) #old rule
      if(length(unique(ax2[ax2$origtaxleveltest==currenttax,"qseqid"]))<3) outcome<-"passed"
      
      #not implementing the length thing here, should I?
     
      if(outcome=="failed"){
      
        yy<-ax.list2[[i]][ax.list2[[i]]$saccver==current,]
        yy<-yy[yy$qseqid!=current,]
       
        #if all hits from an entry are NEVER the same as the origpath, if there were high hits
        if(nrow(yy)>0) if(!yy$hitleveltest[1] %in% yy$origtaxleveltest) if(max(yy$pident)>98) {
          error.filter2[[i]]<-yy 
          message(current," failed_B")
          error.filter2[[i]]$reason<-"filterB"
        } else error.filter2[[i]]<-NULL
      } else error.filter2[[i]]<-NULL
    }
    
    #h
       
    error.filter2<-error.filter2 %>% discard(is.null)
    if(length(error.filter2)>0) {
      error.filter2df<-do.call(rbind,error.filter2)
      error.filter2df<-error.filter2df[order(error.filter2df$saccver,error.filter2df$pident,decreasing = T),]
      error.filter2df<-error.filter2df[,c("qseqid","saccver" ,"pident","origtaxleveltest","hitleveltest","reason","qseq")]
      flagged2<-unique(error.filter2df$saccver)
    } else   {
      flagged2<-NULL
      error.filter2df<-NULL
    }
    
    #combine filter results within h loop
    allerrorsdf[[h]]<-rbind(errorstemp,error.filter2df)
    if(length(allerrorsdf)>0) allerrorsdf[[h]]$taxlevel<-TaxlevelTestall[h]
    allflagged[[h]]<-c(flagged, flagged2)
  } #h
  
  #combine results for all taxon loops
  allerrorsdf<-do.call(rbind,allerrorsdf) #note that some qseqids will be repeated (different taxlevels)
  
  allflagged<-do.call(c,allflagged)
  allflagged<-unique(allflagged)
  # ax_exflagged<-ax[!ax$qseqid %in% allflagged,]
  # ax_exflagged<-ax_exflagged[!ax_exflagged$saccver %in% allflagged,]
  # #min cols
  # ax_exflagged<-ax_exflagged[,c("qseqid","saccver","taxids","pident","origpath","hitpath")]
  
  write.table(allflagged,paste0(outDir,flagged_accessions),row.names = F,quote = F,sep = "\t",col.names = F)
  write.table(allerrorsdf,file = paste0(outDir,flagged_error_detailed_table),quote = F,sep = "\t",row.names = F)
  #write.table(ax_exflagged,file = paste0(outDir,corrected_db),quote = F,sep = "\t",row.names = F)
  
  message("Note: The filter is run three times - at family, genus and species level. 
          There are likely to be duplicates in the output, where the accession was flagged at multiple levels. 
  
  
          Explanation of filters: 
  
          filterA: Indicates qseqid was flagged because
           Apart from itself, all hits >80% belonged to different taxa at this taxlevel (F, G or S) 
            AND there was at least one hit >98%
              AND there were other members of the taxon in the database
                
          filterHu (a special case of filterA): Indicates qseqid was flagged because
           It was not an entry designated as human, but has a hit >98% matching  
           Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens
           
          FilterB: Indicates a saccver was flagged because (note saccver, not qseqid)
            Apart from hitself, this saccver was never in the results for its designated taxon
              AND there were high hits >98%
                AND there other members of the taxon in the database
           ")
  
  rm(ax1)
  rm(ax)
  rm(ax2)
  #rm(ax_exflagged)
  rm(ax.list)
  rm(ax.list2)
  
  message("newly flagged accession numbers")
  print(as.data.frame(allflagged))
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("finding errors complete in ",t3," mins")

  #table size too big for DT
  #message("flagged accession detailed results - inspect carefully")
  # DT::datatable(allerrorsdf, rownames = FALSE, options = list(pageLength = 50, scrollX=T),
  #               caption = "flagged accession detailed results - inspect carefully")
  # #note:DT only working inside this IF statement because it is the last thing in the statement
  #tables not printing!
  # message("newly flagged accession numbers")
  # print(allflagged)
  # 
  
} else message("This step was not set to run")
```

# calc_bar_gap
## basically, plot the blast results indicating the within-taxon variation vs among-taxon variation at F, G & S levels to help to choose appropriate binning thresholds.
## By default, flagged entries from previous step are excluded.  
## What we want to use in the end is the lowest %identity (to limit our loss of reads assigned at each level) that excludes other taxa (to increase resolution). In practice this is a trade-off because we often get overlap of within-taxon variation and among-taxon variation. Feeding these % identities to metabinkit (lca approach), we will never get "wrong" results (unless we still have database errors), but we will just lose resolution if the % identity is too low OR too high. E.g. if species threshold is 95% (caseA), many queries will have hits to multiple species and wont be binned at species-level, but if species threshold is 100% (caseB) many queries will have no hits passing this filter and so also wont be binned at species-level. CaseA can be partially overcome by applying a low "Top.." value.  E.g. if species threshold is 95% but a Top of 1% has been applied, then there will not be as many hits surviving the filters and we will get higher numbers of queries at species-level. How to choose tops? Is using a low top always ok?
```{r plots, eval=TRUE,echo=F,fig.height=7,fig.width=10}
 #STEP3 calculate barcoding gaps
if("calc_bar_gap" %in% steps) {
  
  t1<-Sys.time()
  
  message("Limiting plots to ",plot.limit.taxon)
  
  #read and format fullblast results
  fullblast<-read.and.format.full.blast(input)
  
  #read self-blast results
  ax<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
    
  #add origpath
  ax<-merge(ax,fullblast[,c("saccver", "K","P","C","O","F","G","S","seq.text")], by.x = "qseqid", by.y = "saccver",all.x = T,all.y = F)
  
  rm(fullblast)
  
  #change colnames
    ax$qseq<-ax$seq.text
    ax$seq.text<-NULL
    ax$Ko<-ax$K
    ax$Po<-ax$P
    ax$Co<-ax$C
    ax$Oo<-ax$O
    ax$Fo<-ax$F
    ax$Go<-ax$G
    ax$So<-ax$S
    ax$K<-NULL
    ax$P<-NULL
    ax$C<-NULL
    ax$O<-NULL
    ax$F<-NULL
    ax$G<-NULL
    ax$S<-NULL
    
    #add full origpath
    ax$origpath<-paste(ax$Ko,ax$Po,ax$Co,ax$Oo,ax$Fo,ax$Go,ax$So,sep=";")
    #add hitpath 
    ax<-add.lineage.df(ax,ncbiTaxDir)
    ax$hitpath<-paste(ax$K,ax$P,ax$C,ax$O,ax$F,ax$G,ax$S,sep=";")
    #mincols (note the object name is misleading because these are not ex_flagged)
    ax_exflagged<-ax[,c("qseqid","saccver","taxids","pident","origpath","hitpath")]
    
    #
    if(use_flagged_accessions_bcg) {
      message("Removing flagged accessions")
    #ax_exflagged<-data.table::fread(paste0(outDir,corrected_db),data.table=F,
    #select = c("qseqid","saccver","taxids","pident","origpath","hitpath"))
    flagged<-data.table::fread(paste0(outDir,flagged_accessions),data.table = F,header = F)
     ax_exflagged<-ax_exflagged[!ax_exflagged$qseqid %in% flagged$V1,]
      ax_exflagged<-ax_exflagged[!ax_exflagged$saccver %in% flagged$V1,]
      
    #remove known flags
      if(!is.null(known_flags)) {
        kf<-data.table::fread(known_flags,data.table = F,header = F)
        ax_exflagged<-ax_exflagged[!ax_exflagged$qseqid %in% kf$V1,]
        ax_exflagged<-ax_exflagged[!ax_exflagged$saccver %in% kf$V1,]
      }
    } else message("Not removing any accessions")
    
    rm(ax)
  
    plot.list.loop<-list()
    plot.list.all<-list()
    perc_among_res<-list()
    overlaps<-list()
    potential.errors.out<-list()
    for(h in 1:3){
    
      TaxlevelTest<-TaxlevelTestall[h]
      
      #limit to taxleveltest not unknown
      if(TaxlevelTest=="F") coltax<-5
      if(TaxlevelTest=="G") coltax<-6
      if(TaxlevelTest=="S") coltax<-7
      taxa.unknown<-do.call(rbind,stringr::str_split(ax_exflagged$origpath,";"))[,coltax]
      ax_exflagged<-ax_exflagged[taxa.unknown!="unknown",]
      taxa.unknown<-do.call(rbind,stringr::str_split(ax_exflagged$hitpath,";"))[,coltax]
      ax_exflagged<-ax_exflagged[taxa.unknown!="unknown",]
      
      ax_exflagged$origtaxleveltest<-path.at.level(ax_exflagged$origpath,TaxlevelTest)
      ax_exflagged$hitleveltest<-path.at.level(ax_exflagged$hitpath,TaxlevelTest)
  
      #within taxlevel vs among tax level range
      newtab<-data.frame(matrix(ncol=6,nrow = length(unique(ax_exflagged$origtaxleveltest))))
      colnames(newtab)<-c("taxon","max_within","min_within","max_among","min_among","max_among_saccver")
      
      
      ax_exflagged.spl<-split(ax_exflagged,ax_exflagged$origtaxleveltest)
      
      for(i in 1:length(ax_exflagged.spl)){
        temp<-ax_exflagged.spl[[i]]
        taxoni<-temp$origtaxleveltest[1]
        newtab$taxon[i]=taxoni
        newtab$max_within[i]=max(temp[temp$hitleveltest==taxoni,"pident"])
        newtab$min_within[i]=min(temp[temp$hitleveltest==taxoni,"pident"])
        
        if(nrow(temp[temp$hitleveltest!=taxoni,])>0){
          newtab$max_among[i]=max(temp[temp$hitleveltest!=taxoni,"pident"])
          newtab$min_among[i]=min(temp[temp$hitleveltest!=taxoni,"pident"])
          newtab$max_among_saccver[i]=temp[temp$hitleveltest!=taxoni,"saccver"][1]
        } else {
          #stop(i)
          newtab$max_among[i]=0
          newtab$min_among[i]=0
        }
      }
      
      #print overlaps for inspection later
      overlaps[[h]]<-unique(newtab[newtab$max_among>=99,"taxon"])
      
      message("Taxa with among-taxa variarion >= 99% at ",TaxlevelTestall[h]," level.
              Inspect ",further_potential_errors," for further details and to manually flag accessions")
      
      if(length(overlaps[[h]])>0){
        print(overlaps[[h]])
        
        # if(TaxlevelTestall[h]=="F") print.details.among<-print.details.among.F
        # if(TaxlevelTestall[h]=="G") print.details.among<-print.details.among.G
        # if(TaxlevelTestall[h]=="S") print.details.among<-print.details.among.S
        # 
        #if(print.details.among){
        #message("Details of hits for taxa with among-taxa variarion >= 99% at ",TaxlevelTestall[h]," level.")
        potential.errors<-list()
          for(j in 1:length(overlaps[[h]])){
            #message(overlaps[[h]][j])
            xy<-ax_exflagged[ax_exflagged$origtaxleveltest==overlaps[[h]][j],] 
            xy<-xy[xy$pident>=99,] 
            potential.errors[[j]]<-xy[xy$hitleveltest!=overlaps[[h]][j],]
          }
        
        potential.errors.out[[h]]<-do.call(rbind,potential.errors)
        potential.errors.out[[h]]$level<- TaxlevelTest
      } else {
        message("No further potential errors found")
        potential.errors.out[[h]]<-NULL
      }
      
  
    #plot
    newtablong<-reshape2::melt(newtab[,c("taxon","max_within","min_within","max_among","min_among")],id.vars="taxon")
    
    #plot limit
    if(!is.null(plot.limit.taxon)) newtablong<-newtablong[grep(plot.limit.taxon,newtablong$taxon),]
     
    newtablong$groups<-""
    newtablong$groups[newtablong$variable=="max_within" | newtablong$variable=="min_within"]<-paste("within",TaxlevelTest,"range")
    newtablong$groups[newtablong$variable=="max_among" | newtablong$variable=="min_among"]<-paste("among",TaxlevelTest,"range")
    
    plota<-ggplot(newtablong,aes(x = taxon,y = value,colour=groups,group=interaction(taxon,groups)))+geom_point()+
      theme(axis.text.x=element_text(size=8,angle=45, hjust=1),legend.title = element_blank(),
            panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.background = element_blank(),
            axis.line = element_line(colour = "black"))+
      geom_line()+ylab("Percentage identity")+xlab("")
    
    #add to ax_exflagged file to make it easy to look up later
    # ax_exflagged<-merge(ax_exflagged,newtab[,c("taxon","max_among_saccver")],by.x="origtaxleveltest",by.y="taxon")
    # if(TaxlevelTest=="S") ax_exflagged$max_among_S<-ax_exflagged$max_among_saccver
    # if(TaxlevelTest=="G") ax_exflagged$max_among_G<-ax_exflagged$max_among_saccver
    # if(TaxlevelTest=="F") ax_exflagged$max_among_F<-ax_exflagged$max_among_saccver
    # ax_exflagged<-ax_exflagged[,-match("max_among_saccver",colnames(ax_exflagged))]
    
    #counts. 
    values<-seq(100,50,-1)
    res<-data.frame(pident=values,nTaxaWithin=0,nTaxaAmong=0)
    for(i in 1:length(values)){
      xx<-newtablong[newtablong$value>=values[i],]
      res[i,"nTaxaWithin"]<-length(unique(xx[grep("within",xx$groups),"taxon"])) 
      res[i,"nTaxaAmong"]<-length(unique(xx[grep("among",xx$groups),"taxon"]))
    }
    
    #plot res
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt$nTaxa<-resmelt$value
    
    plotb<-ggplot(resmelt,aes(x = pident,y = nTaxa,colour=variable))+geom_point()
      
    res$percent_among<-res$nTaxaAmong/res$nTaxaWithin*100
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt<-resmelt[resmelt$variable=="percent_among",]
    resmelt$percent_among<-resmelt$value
    
    plotc<-ggplot(resmelt,aes(x = pident,y = percent_among))+geom_point()
    
    #table of perc_within
    resx<-res[res$pident %in% c(100,99,98,97,96,95,90,85,80,75,70,65,60,50),]
    resx$percent_among<-round(resx$percent_among,digits = 0)
    perc_among_res[[h]]<-resx
    
    plot.list.loop[[1]]<-plota
    plot.list.loop[[2]]<-plotb
    plot.list.loop[[3]]<-plotc
    plot.list.all[[h]]<-plot.list.loop
    
    # #table of tops (diff)
    # newtab$diff<-newtab$min_within-newtab$max_among
    # #plot limit
    # if(!is.null(plot.limit.taxon)) newtab<-newtab[grep(plot.limit.taxon,newtab$taxon),]
    # ##change diff to zero if negative
    # newtab$diff[newtab$diff<0]<-0
    # 
    # diffs<-newtab[newtab$diff %in% c(100,95,90,85,80,75,70,65,60,50),]
    # resx$percent_among<-round(resx$percent_among,digits = 0)
    # perc_among_res[[h]]<-resx
    # 
    # ggplot(newtab,aes(x = taxon,y = diff))+geom_point()+
    #   theme(axis.text.x=element_text(size=8,angle=45, hjust=1),legend.title = element_blank(),
    #         panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.background = element_blank(),
    #         axis.line = element_line(colour = "black"))
    
    } #end h-loop
    
    #gather all potential errors and save in file
  potential.errors.out<- do.call(rbind,potential.errors.out)
  potential.errors.out<-potential.errors.out[,c("qseqid","saccver","taxids", "pident" ,"origpath","hitpath","level")]
  write.table(potential.errors.out,paste0(outDir,further_potential_errors),row.names=F,quote=F,sep="\t")
    
  #plots
  for(h in 1:3){
    print(plot.list.all[[h]][[1]])  
    print(plot.list.all[[h]][[2]])  
    print(plot.list.all[[h]][[3]])  
  }
  
  #reorder ax
  # ax_exflagged<-ax_exflagged[order(ax_exflagged$qseqid,ax_exflagged$pident,decreasing = T),]
  # ax_exflagged<-ax_exflagged[,c("qseqid","saccver","taxids", "pident","origpath", "hitpath","max_among_S" ,"max_among_G" ,"max_among_F" )] 
  # 
  # message("Adding accession numbers of closest taxon to ",paste0(outDir,corrected_db))
  # write.table(ax_exflagged,file = paste0(outDir,corrected_db),quote = F,sep = "\t",row.names = F)

  message("The following tables indicate, for each % threshold, the number of times that taxa from different families/genera/species are within the threshold (nTaxaAmong)")
  
  message("Family level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[1]])
  message("Genus level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[2]])
  message("Species level")
  if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
  print(perc_among_res[[3]])
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("calculating barcode gaps in ",t3," mins")
  
} else message("This step was not set to run")
    
```
