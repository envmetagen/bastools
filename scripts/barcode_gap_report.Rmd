---
title: "Barcode Gap Report, Database Error Flagging, Taxonomic Assignment Threshold Analysis"
html_notebook: default
subtitle: ''
classoption: portrait
output: html_document
includes:  
      #in_header: rmarkdownsettings.txt
      extra_dependencies: ["float"]
---
## The input is the result of a "thorough" blast against a large database, e.g. nt. Or it could be the results of any full length alignment (as long as the alignment has a very diverse array of taxa, and a lot of sequences). e.g. it could be ecoPCR output (properly formatted)
### e.g. blastn -query my.fasta -db nt -outfmt '6 qseqid saccver staxid pident sseq' -evalue 1 -max_target_seqs 100 -max_hsps 1 -word_size 11 -perc_identity 50 -qcov_hsp_perc 98 -gapopen 0 -gapextend 2 -reward 1 -penalty -1 -dust no -out my.blast.tsv
### In any case I recommend such settings for metabarcoding in general, although it takes longer, as they are much more informative, intuitive and useful.
### megablast and longer word size ok, main thing is the gap extension settings to ensure full length alignments (min 98% cover), as anything less is not good for metabarcoding
```{r load functions, eval=TRUE, results='hide',echo=F}
knitr::opts_chunk$set(fig.pos = "!H", out.extra = "")
source(paste0(bastoolsDir,"master_functions.R"))
library(ggplot2)
library(tidyverse)
options(httr_oob_default = TRUE)
all.stats<-list()

read.and.format.full.blast<-function(input,known_flags=NULL,rm.low.read.queries=0.90){
  #rm.low.read.queries means remove queries where size (in qseqid) < quantile 90% e.g. 90% of reads might have 35 reads or more
  
  require(stringr)
  
  #read full blast results
  fullblast<-data.table::fread(input,data.table=F, select = c("saccver","taxids","pident","sseq","qseqid")) #qseqid only for read size
  
    #remove hits to low abundance reads
  if(!is.null(rm.low.read.queries)) {
  fullblast$otu_sizes<-as.numeric(stringr::str_split(fullblast$qseqid,"size=",simplify = T)[,2])
  cutoff<-quantile(fullblast$otu_sizes,rm.low.read.queries)
  fullblast<-fullblast[fullblast$otu_sizes>=cutoff,]
  message("Not testing queries that had a read count less than ",cutoff," (quantile=",rm.low.read.queries*100,"%)")
  }
  
  #remove known flags
  if(!is.null(known_flags)) {
    message("Removing hits to known flags")
    if(!file.exists(known_flags)) stop(known_flags,"not found")
    before<-length(unique(fullblast$saccver))
    kf<-data.table::fread(known_flags,data.table = F,header = F)
    fullblast<-fullblast[!fullblast$saccver %in% kf$V1,]
    message(before-length(unique(fullblast$saccver))," hits removed")
  }
    
  #remove hyphens sseq
  fullblast$sseq<-gsub("-","",fullblast$sseq)
  
  #need to reduce db size. not sure of best option!
  ##currently- using the saccver that had the best hit in original blast, but only keep 10 per taxid maximum
  fullblast<-fullblast[order(fullblast$pident,decreasing = T),]
  fullblast<-fullblast[!duplicated(fullblast$saccver),] 
  #limit to max 10 per taxid to overcome the "thunnus issue" (having 100s of hits to one taxon)
  fullblast_spl<-split(fullblast,fullblast$taxids)
  for(i in 1:length(fullblast_spl)){
    if(nrow(fullblast_spl[[i]])>10) fullblast_spl[[i]]<-fullblast_spl[[i]][1:10,]
  }
  #keep best hit per saccver=22050
  #keep best per saccver, but only those that had >70% pidents=16390, 80%=9483
  #keep best hit per sseq=29796
  #keep best hit per staxid=9419, 
  #if then only keeping unique sseqs->7953 (could then map results back later,but I have not implemented this)
  #keep best hit per species=8765 (think this is not ideal)
  
  fullblast<-do.call(rbind,fullblast_spl)
  
  rm(fullblast_spl)
  
  #make new header names with taxids, for building db
  fullblast$seq.name<-paste0(fullblast$saccver," taxid=", fullblast$taxids,"; ")
  
  #add seq.text, for phylotools
  fullblast$seq.text<-fullblast$sseq 
  
  #add lineages for later
  fullblast<-add.lineage.df(fullblast,ncbiTaxDir)
  fullblast$origpath<-paste(fullblast$K,fullblast$P,fullblast$C,fullblast$O,fullblast$F,fullblast$G,fullblast$S,sep=";")
  
  fullblast<-fullblast[,c("saccver","taxids","seq.name","seq.text","origpath")]
  
  colnames(fullblast)<-c("origseqid","origtaxid","seq.name","seq.text","origpath")
  
  return(fullblast)
} 
```

## STEP1 SELF BLAST
### Convert the sseqs into a blast database, select all saccvers that had >80% identity. Output a krona plot of the database, to see what is in it
```{r self blast, eval=TRUE,echo=F}

if("selfblast" %in% steps) {
  
  t1<-Sys.time()
  
  fullblast<-read.and.format.full.blast(input) 
  
  #MAKE KRONA OF DB
  x<-as.data.frame(table(fullblast$origpath))
  colnames(x)<-c("taxon","count")
  bas.krona.plot(taxatable = x,out = paste0(outDir,krona_html_db),KronaPath = KronaPath)
  message("krona plot for self-blast database saved to ", paste0(outDir,krona_html_db))
  
  #make fasta of DB
  phylotools::dat2fasta(fullblast[,c("seq.name","seq.text")],paste0(outDir,"tempBLASTDB.fasta"))
  
  #make blastdb using metabinkit
  system2("metabinkit_blastgendb",c("-f",paste0(outDir,"tempBLASTDB.fasta"),"-o", paste0(outDir,"tempBLASTDB"),"-c"),wait = T)
  
  message("straight SELF-BLAST running...")
  
  if(!exists("divergence")) {
    divergence<-rep(5,length(TaxlevelTestall))
    message("Defaulting to divergence of 5 for all levels")
  }
  
  #perc_identity<-98-max(divergence)-5 #adding the minus 5 just to catch a few more hits, 98 because this is what I use later to say there were "high" hits
  perc_identity<-70
  #changing to blanket 70, to match that used by threshold.bin.blast2
  
  message("word_size set to 20. This was tested for a fragment of c. 105bp and did not result in many fewer hits than word_size of 11 (word_size 28 did), but if testing a shorter fragment consider revising")
  
  argsblast=c("-task","megablast", "-query", paste0(outDir,"tempBLASTDB.fasta"), "-db",paste0(outDir,"tempBLASTDB"),"-outfmt",
                 "'6 qseqid saccver staxid pident sseq'","-evalue",1,"-num_threads", 64, "-max_target_seqs", 
                 500, "-max_hsps",1,"-word_size", 20,"-perc_identity", perc_identity,"-qcov_hsp_perc",98,
                 "-gapopen", 0, "-gapextend", 2, "-reward", 1, "-penalty", -1, "-dust","no", "-out", 
                 paste0(outDir,selfblastout))
  
  message(argsblast)
  
  system2(command = "blastn",args=argsblast, wait = T)
  
  headers<-paste0("'1i",paste(c("origseqid", "hitseqid", "hittaxid", "pident","hitseq"),collapse = "\t"),"'")
  
  system2("sed",c("-i", headers, paste0(outDir,selfblastout)),wait = T)
  
  #combine all necessary info and output single table
  ##read self-blast
  sb<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
  #remove hyphens sseq
  sb$hitseq<-gsub("-","",sb$hitseq)
  
  #add hit path
  sb<-add.lineage.df(sb,ncbiTaxDir,taxCol = "hittaxid")
  sb$hitpath<-paste(sb$K,sb$P,sb$C,sb$O,sb$F,sb$G,sb$S,sep=";")
  sb<-sb[,c("origseqid", "hitseqid", "hittaxid", "pident","hitseq","hitpath")]
  
  ##add origpath and origseq to selfblast
  sb<-merge(sb,fullblast[,c("origseqid","origtaxid", "origpath","seq.text")], by="origseqid",all.x = T,all.y = F)
  colnames(sb)<-gsub("seq.text","origseq",colnames(sb))
  sb<-sb[,c("origseqid","hitseqid","pident","origtaxid","hittaxid", "origpath","hitpath","origseq","hitseq")] #seq.text=origseq
  
  rm(fullblast)
  
  write.table(sb,paste0(outDir,selfblastout),quote = F,row.names = F,sep = "\t")
  
  #remove tempdb
  file.remove(list.files(pattern = "tempBLASTDB.n.*"))
  file.remove("tempBLASTDB.fasta")
  file.remove("tempBLASTDB.taxid_map.tsv")
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("self-blast complete in ",t3," mins")
  
} else message("This step was not set to run")

```

## Find database errors
### For each taxonomic level (F,G,S) look for potentially misassigned entries (see output for rules). 
### Outputs
#### The list of flagged accessions
#### A detailed table of the flagged accessions (for manual double-checking)
### So far haven seen any flagged accessions that seem incorrectly flagged. But not all errors are caught. Main case is when there are multiple erroneously labelled entries of the same taxon. 
```{r find_db_errors, eval=TRUE,echo=F}
if("find_db_errors" %in% steps) {
  
  ##TODO outputting the specific reasons fo passing in the output would help, particularly for the bc output 
  
  t1<-Sys.time()

  allerrors<-list()
  allflagged<-list()
  ax_exflagged<-list()
  
  #read selfblastresults
  sb<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
  
  before<-length(unique(sb$origseqid))
  
  sbtemp<-sb
  
  #remove XM_,XR_,XP_ accessions These are 'PREDICTED' in-silico generated
  message("excluding 'PREDICTED', in-silico generated, accessions")
  if(length(grep("XM_.*",sb$origseqid))>0) sb<-sb[-grep("XM_.*",sb$origseqid),] 
  if(length(grep("XR_.*",sb$origseqid))>0) sb<-sb[-grep("XR_.*",sb$origseqid),] 
  if(length(grep("XP_.*",sb$origseqid))>0) sb<-sb[-grep("XP_.*",sb$origseqid),] 
  if(length(grep("XM_.*",sb$hitseqid))>0) sb<-sb[-grep("XM_.*",sb$hitseqid),] 
  if(length(grep("XR_.*",sb$hitseqid))>0) sb<-sb[-grep("XR_.*",sb$hitseqid),] 
  if(length(grep("XP_.*",sb$hitseqid))>0) sb<-sb[-grep("XP_.*",sb$hitseqid),] 
  
  message("'PREDICTED' in-silico sequences removed:",before-length(unique(sb$origseqid)))
  removed.accs<-sbtemp[!sbtemp$origseqid %in% unique(sb$origseqid),]
  removed.accs<-removed.accs[!duplicated(removed.accs$origseqid),c("origseqid","origpath")]
  print(removed.accs)
  
  rm(sbtemp)
    
  #remove known flags
  if(!is.null(known_flags)) {
    beforeaccs<-unique(sb$origseqid)
    before<-length(beforeaccs)
    kf<-data.table::fread(known_flags,data.table = F,header = F)
    sb<-sb[!sb$origseqid %in% kf$V1,]
    sb<-sb[!sb$hitseqid %in% kf$V1,]
    message("Known flagged sequences removed:",before-length(unique(sb$origseqid)))
    print(kf$V1)
  }
  
  #loop by taxa level (FGS), fnding errors for each level
  hierarchy<-c("K","P","C","O","F","G","S")
  
  if(!exists("divergence")) {
    divergence<-rep(5,length(TaxlevelTestall))  ##TODO change this if extending to other levels
    message("Defaulting to divergence of 5 for all levels")
  }
    
  #if 5 then a query will fail if the genus is not present within 5% identity of the top hit, but how to choose? 
  #could vastly speed this up bydoing species first and onyl testing those that failed at genus and family
  #now that Iá¸¿ going to kpco levels, this is more nb
  for(h in 1:length(TaxlevelTestall)){
    
    if(h>1) sb<-sbtemp
    
    TaxlevelTest<-TaxlevelTestall[h]
    
    message("finding errors in database using taxlevel ",TaxlevelTest)
  
    #limit to taxleveltest not unknown for both origpath and hitpath (i.e. both must have taxonomy at this level)
    ##make split taxonomy
    sb$origtax<-stringr::str_split(sb$origpath,";",simplify = T)[,match(TaxlevelTest,hierarchy)]
    sb$hittax<-stringr::str_split(sb$hitpath,";",simplify = T)[,match(TaxlevelTest,hierarchy)]
    
    sb<-sb[sb$origtax!="unknown",]
    sb<-sb[sb$hittax!="unknown",]
    
    #if TaxlevelTest[i]="S" remove sp.-type entries, from both orig and hit  
    if(TaxlevelTest=="S"){
      message("Removing species with 'sp.', numbers or more than one space")
      
       if(length(grep(" sp\\.",sb$origtax,ignore.case = T))>0) sb<-sb[-grep(" sp\\.",sb$origtax,ignore.case = T),]
       if(length(grep(" .* .*",sb$origtax,ignore.case = T))>0) sb<-sb[-grep(" .* .*",sb$origtax,ignore.case = T),]
       if(length(grep("[0-9]",sb$origtax))>0) sb<-sb[-grep("[0-9]",sb$origtax),]
      
       if(length(grep(" sp\\.",sb$hittax,ignore.case = T))>0) sb<-sb[-grep(" sp\\.",sb$hittax,ignore.case = T),]
       if(length(grep(" .* .*",sb$hittax,ignore.case = T))>0) sb<-sb[-grep(" .* .*",sb$hittax,ignore.case = T),]
       if(length(grep("[0-9]",sb$hittax))>0) sb<-sb[-grep("[0-9]",sb$hittax),]

      #remove crappy hits 
       
       message("Removing species containing the terms: uncultured, environmental, 
            unidentified,fungal, eukaryote, unclassified, synthetic")
       
       crap<-c("uncultured","environmental","unclassified","unidentified","fungal ","eukaryote","synthetic")
       
       for(i in 1:length(crap)){
         if(length(grep(crap[i],sb$origtax,ignore.case = T))>0) sb<-sb[-grep(crap[i],sb$origtax,ignore.case = T),]
         if(length(grep(crap[i],sb$hittaxid,ignore.case = T))>0) sb<-sb[-grep(crap[i],sb$hittaxid,ignore.case = T),]
       }
    }
   
    #order
    sb<-sb[order(sb$pident,decreasing = T),]
    
    #add path of current level
    sb$origleveltest<-path.at.level(sb$origpath,TaxlevelTest)
    sb$hitleveltest<-path.at.level(sb$hitpath,TaxlevelTest)
     
    ###filterA
    sb.list<-split(sb,sb$origseqid)
    sbtemp<-sb
    errors<-list()
    
    for(i in 1:length(sb.list)){
      
      #      if(sb.list[[i]]$origseqid[1]=="DQ485816.1") stop(i)
       #    }
      outcome<-"failed"
      
      #remove self-hit
      xx<-sb.list[[i]][sb.list[[i]]$hitseqid!=sb.list[[i]]$origseqid[1],]
      
      #if no other hits, cannot fail
      if(nrow(xx)==0) outcome<-"passed"
      
      #human test
      if(outcome=="failed") {
        #still assigns other primates as likely human, skip primates
        if(length(grep("Eukaryota;Chordata;Mammalia;Primates",xx$origpath[1]))!=1) {
          if("Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens" %in% xx$hitpath) {
            if(max(xx[xx$hitpath=="Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens","pident"])>98) outcome<-"human"
          }
        }
      }
      
      #an issue here. if max_target_seqs was too low in original blast then all hits might be above e.g. 99% and we might not have hits to other members of the taxon, even though they are very similar. then will be incorrectly flagged. So can only fail if we have "distant" hits in our results.
      
      #apply a top value, e.g. 10%. otherwise our query family is likely to be in results, even though many closer hits
      #but should know what the lowest contains 10% divergence (i.e. that full results didnt only go to e.g. 96%), if it does not then pass it
      if(outcome=="failed") if(min(xx$pident)>max(xx$pident)-divergence[h]) outcome<-"passed" 
      if(outcome=="failed") xx<-xx[xx$pident>=max(xx$pident)-divergence[h],] 
      
      #all other hits belong to other families only
      if(outcome=="failed") if(xx$origleveltest[1] %in% xx$hitleveltest) outcome<-"passed"
      
      #remaining families contain a high hit (e.g. 98%)
      if(outcome=="failed" | outcome=="human") if(max(xx$pident)<98) outcome<-"passed"
          
      #if database doesnt contain at least 3 other representatives of the taxon, then pass it. If it does contain 3 other representatives then fail it, but only if other representatives have at least 3 sequences that are within 2% of query length (otherwise they wont be in blast results and can be erroneously flagged)
      if(outcome=="failed") {
        
        if(length(unique(sbtemp[sbtemp$origleveltest==xx$origleveltest[1],"origseqid"]))>3) { 
          qlen<-nchar(xx$origseq[1])
          minslen<-round(qlen*0.981,digits = 0) #just adding to one to be sure it is above
          seqs.in.group<-sbtemp[sbtemp$origleveltest==xx$origleveltest[1],c("origseqid", "origseq")]
          seqs.in.group<-seqs.in.group[!duplicated(seqs.in.group$origseqid),]
          seqs.in.group<-seqs.in.group[!seqs.in.group$origseqid==xx$origseqid[1],]
          slens<-nchar(seqs.in.group$origseq)
          slens<-slens[slens>=minslen]
          
          if(length(slens)<3) outcome<-"passed" 
        
        } else outcome<-"passed"
      }
  
     if(outcome=="failed" | outcome=="human") {
        errors[[i]]<-sb.list[[i]]
        current<-sb.list[[i]]$origseqid[1]
        if(outcome=="failed") {
          message(current," failed_A ",TaxlevelTestall[h]," ",xx$origleveltest[1],"
          ",xx$origseq[1])
          errors[[i]]$reason<-"filterA"
          errors[[i]]$taxlevel<-TaxlevelTestall[h]
        }
        if(outcome=="human") {
          message(current," failedHu - possible human ",TaxlevelTestall[h]," ",xx$origleveltest[1],"
          ",xx$origseq[1])
          errors[[i]]$reason<-"filterHu"
          errors[[i]]$taxlevel<-TaxlevelTestall[h]
        }
        #remove from db before next loop.
        sb.list<-lapply(sb.list,function(x) x<-x[x$hitseqid!=current,]) #this will be reused within this i loop
        sbtemp<-do.call(rbind,sb.list) #sbtemp will be carried to filterB
        sbtemp<-sbtemp[sbtemp$origseqid!=current,]
      } else errors[[i]]<-NULL
    } #end of i
    
    #h
    
    #collate errors
    errors<-errors %>% discard(is.null)
    
    if(length(errors)>0) {
      errors<-do.call(rbind,errors)
      errors<-errors[,c("origseqid","hitseqid" ,"pident","origleveltest","hitleveltest","reason","taxlevel","origseq","hitseq")]
      flagged<-unique(errors$origseqid)
    } else {
      errors<-NULL
      flagged<-NULL
    }
    
    #FILTER_B
    #second filter based on hits rather than queries. if a hitpath is NEVER the same as the origpath (despite multiple queries matching that hit), likely an error
    #AND there were high hits
    #AND there at least three other members of the taxonlevel in the database
    
    sb.list<-split(sbtemp,sbtemp$hitseqid)
    errorsB<-list()
    for(i in 1:length(sb.list)){
      
     #  if(sb.list[[i]]$hitseqid[1]=="AC197159.2") stop(i)
      #}
    
    outcome<-"failed"
    current<-unique(sb.list[[i]]$hitseqid)[1]
    currenttax<-sb.list[[i]]$hitleveltest[1]
    
    yy<-sb.list[[i]][sb.list[[i]]$origseqid!=current,]
        
    if(nrow(yy)==0) outcome<-"passed"
    
     #apply a top value, e.g. 10%. otherwise our query family is likely to be in results, even though many closer hits
      #but should know what the lowest contains 10% divergence (i.e. that full results didnt only go to e.g. 96%), if it does not then pass it
    if(outcome=="failed") if(min(yy$pident)>max(yy$pident)-divergence[h]) outcome<-"passed" 
    
    if(outcome=="failed") yy<-yy[yy$pident>=max(yy$pident)-divergence[h],] 
    
    if(outcome=="failed") if(yy$hitleveltest[1] %in% yy$origleveltest) outcome<-"passed" 
      
    if(outcome=="failed") if(max(yy$pident)<98) outcome<-"passed" 
    
      #if database doesnt contain at least 3 other representatives of the taxon, then pass it. If it does contain 3 other representatives then fail it, but only if other representatives have at least 3 sequences that are within 2% of query length (otherwise they wont be in blast results and can be erroneously flagged)
    if(outcome=="failed") if(length(unique(sbtemp[sbtemp$origleveltest==currenttax,"origseqid"]))>3) { 
          sseq<-sbtemp[sbtemp$origseqid==current,"origseq"][1]
          slen<-nchar(sseq)
          maxqlen<-round(slen*1.0199,digits = 0) #just minusing the one to be sure it is below
          seqs.in.group<-sbtemp[sbtemp$origleveltest==currenttax,c("origseqid", "origseq")]
          seqs.in.group<-seqs.in.group[!duplicated(seqs.in.group$origseqid),]
          seqs.in.group<-seqs.in.group[!seqs.in.group$origseqid==current,]
          qlens<-nchar(seqs.in.group$origseq)
          qlens<-qlens[qlens<=maxqlen]
          if(length(qlens)<3) outcome<-"passed" 
        } else outcome<-"passed"
    
    
      #if all hits remaining from an entry are NEVER the same as the origpath, and there were high hits then fail
        if(outcome=="failed") {
          errorsB[[i]]<-yy 
          message(current," failed_B ",TaxlevelTestall[h]," ",yy$hitleveltest[1],"
          ",sseq)
          errorsB[[i]]$reason<-"filterB"
          errorsB[[i]]$taxlevel<-TaxlevelTestall[h]
          #remove from db before next loop.  
          sb.list<-lapply(sb.list,function(x) x<-x[x$origseqid!=current,]) #this will be reused within this i loop
          sbtemp<-do.call(rbind,sb.list) #sbtemp will be carried to next h loop
          sbtemp<-sbtemp[sbtemp$hitseqid!=current,]
        } else errorsB[[i]]<-NULL
    
    } #end of i
   
    #h
       
    errorsB<-errorsB %>% discard(is.null)
    if(length(errorsB)>0) {
      errorsB<-do.call(rbind,errorsB)
      errorsB<-errorsB[order(errorsB$hitseqid,errorsB$pident,decreasing = T),]
      errorsB<-errorsB[,c("origseqid","hitseqid" ,"pident","origleveltest","hitleveltest","reason","taxlevel","origseq","hitseq")]
      flaggedB<-unique(errorsB$hitseqid)
    } else   {
      flaggedB<-NULL
      errorsB<-NULL
    }
    
    #combine filter results within h loop
    allerrors[[h]]<-rbind(errors,errorsB)
    allflagged[[h]]<-c(flagged, flaggedB)
  } #end h
  
  #should start with lowest taxon level (e.g. genus) and move uowards after each loop, should only 1) repeat those that failed to see if they fail at higher level 2) do those that werent included in previous rounds. will be much faster
  
  #combine results for all taxon loops
  allerrorsdf<-do.call(rbind,allerrors) 
  allflagged<-do.call(c,allflagged)
  if(length(removed.accs$origseqid)>0) allflagged<-unique(c(removed.accs$origseqid,allflagged))
  
  write.table(allflagged,paste0(outDir,flagged_accessions),row.names = F,quote = F,sep = "\t",col.names = F)
  write.table(allerrorsdf,file = paste0(outDir,flagged_error_detailed_table),quote = F,sep = "\t",row.names = F)

  message("Note: The filter will run at each taxonomic level specified. 
          
          Explanation of filters: 
  
          filterA: Indicates query was flagged because
           All hits within specified 'divergence' of the best hit belonged to a different taxon at this taxlevel  
            AND there was at least one hit >98%
             AND there were at least three other members of the taxon in the database (i.e. it is reasonably represented)
              AND at least three of the sequences of the other members were a similar length (98% qcov) 
                
          filterHu (a special case of filterA): Indicates qseqid was flagged because
           It was not an entry designated as a primate, but has a hit >98% matching  
           Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens
           
          FilterB: Indicates a subject was flagged because
            All queries within specified 'divergence' of the best hit match to this subject belonged to a different taxon at this taxlevel
              AND there were high hits >98%
                AND there were at least three other members of the taxon in the database (i.e. it is reasonably represented)
                 AND at least three of the sequences of the other members were a similar length (98% qcov) 
           ")
  
  message("newly flagged accession numbers")
  print(as.data.frame(allflagged))
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("finding errors complete in ",t3," mins")
  
} else message("This step was not set to run")
```

# Calculate barcoding gap
## Plot the self-blast results indicating the within-taxon variation vs among-taxon variation at F, G & S levels to help to choose appropriate binning thresholds.
## What we want to use in the end is the lowest %identity (to limit our loss of reads assigned at each level) that excludes other taxa (to increase resolution). In practice this is a trade-off because we often get overlap of within-taxon variation and among-taxon variation. 
## Outputs
### For each level, a plot of within-taxon variation vs among-taxon variation
### For each level, a plot and table of the number and percentage of taxa that have barcode overlaps (ambiguity) at each % identity
### A table of further potential errors (entries that had >99% to other taxa) for manual inspection
```{r calc_bar_gap, eval=TRUE,echo=F,fig.height=7,fig.width=10}
 #STEP3 calculate barcoding gaps
if("calc_bar_gap" %in% steps) {
  
  t1<-Sys.time()
  
  if(!is.null(plot.limit.taxon)) message("Limiting plots to ",plot.limit.taxon)
  
    #read selfblastresults
    sbo<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
    
    
  remove.taxa.from.list<-function(BL,sbo,ncbiTaxDir = ncbiTaxDir){
    species_bl<-data.table::fread(BL,data.table = F, header = F)
    species_bl<-species_bl[!is.na(species_bl$V1),,drop=F]
    exclude<-get.children.taxonkit(df = species_bl,column = "V1",ncbiTaxDir = ncbiTaxDir)
    sbo<-sbo[!sbo$hittaxid %in% exclude,]
    sbo<-sbo[!sbo$origtaxid %in% exclude,]
  }
  
  if(!is.null(SpeciesBL)) {
    message("Disabling species")
    sbo<-remove.taxa.from.list(BL = SpeciesBL,sbo = sbo,ncbiTaxDir = ncbiTaxDir)
  }
  
  if(!is.null(GenusBL)) {
    message("Disabling genera")
    sbo<-remove.taxa.from.list(BL = GenusBL,sbo = sbo,ncbiTaxDir = ncbiTaxDir)
  }
  
  if(!is.null(FamilyBL)) {
    message("Disabling families")
    sbo<-remove.taxa.from.list(FamilyBL,sbo,ncbiTaxDir = ncbiTaxDir)
  }  
  
  #write.table(sb2,paste0(blast.thresh.input,"temp"),append = F,sep = "\t",quote = F,row.names = F)
    
    if(use_flagged_accessions_bcg) {
      message("Removing newly flagged accessions")
    
      flagged<-data.table::fread(paste0(outDir,flagged_accessions),data.table = F,header = F)
      if(nrow(flagged)>0) {
        sbo<-sbo[!sbo$origseqid %in% flagged$V1,]
        sbo<-sbo[!sbo$hitseqid %in% flagged$V1,]
      } else message("No newly flagged accessions")
    } else message("Not removing newly flagged accessions")
      
    #remove known flags
      if(!is.null(known_flags)) {
        message("Removing known flagged accessions")
        kf<-data.table::fread(known_flags,data.table = F,header = F)
        sbo<-sbo[!sbo$origseqid %in% kf$V1,]
        sbo<-sbo[!sbo$hitseqid %in% kf$V1,]
      } else message("Not removing any known_flags")
    
  plot.list.loop<-list()
  plot.list.all<-list()
  perc_among_res<-list()
  overlaps<-list()
  potential.errors.out<-list()
  
   #loop by taxa level, plotting errors for each level
  hierarchy<-c("K","P","C","O","F","G","S")
  
  for(h in 1:length(hierarchy)){
    
    sb<-sbo
  
    TaxlevelTest<-hierarchy[h]
    
    #limit to taxleveltest not unknown
    sb$origtax<-stringr::str_split(sb$origpath,";",simplify = T)[,match(TaxlevelTest,hierarchy)]
    sb$hittax<-stringr::str_split(sb$hitpath,";",simplify = T)[,match(TaxlevelTest,hierarchy)]
    sb<-sb[sb$origtax!="unknown",]
    sb<-sb[sb$hittax!="unknown",]
    
    sb$origleveltest<-path.at.level(sb$origpath,TaxlevelTest)
    sb$hitleveltest<-path.at.level(sb$hitpath,TaxlevelTest)

    #within taxlevel vs among tax level range
    newtab<-data.frame(matrix(ncol=6,nrow = length(unique(sb$origleveltest))))
    colnames(newtab)<-c("taxon","max_within","min_within","max_among","min_among","max_among_hitseqid")
    
    sb.spl<-split(sb,sb$origleveltest)
    
    for(i in 1:length(sb.spl)){
      temp<-sb.spl[[i]]
      taxoni<-temp$origleveltest[1]
      newtab$taxon[i]=taxoni
      newtab$max_within[i]=max(temp[temp$hitleveltest==taxoni,"pident"])
      newtab$min_within[i]=min(temp[temp$hitleveltest==taxoni,"pident"])
      
      if(nrow(temp[temp$hitleveltest!=taxoni,])>0){
        newtab$max_among[i]=max(temp[temp$hitleveltest!=taxoni,"pident"])
        newtab$min_among[i]=min(temp[temp$hitleveltest!=taxoni,"pident"])
        newtab$max_among_hitseqid[i]=temp[temp$hitleveltest!=taxoni,"hitseqid"][1]
      } else {
        #stop(i)
        newtab$max_among[i]=0
        newtab$min_among[i]=0
      }
    }
    
    #print overlaps for inspection later
    overlaps[[h]]<-unique(newtab[newtab$max_among>=99,"taxon"])
    
    message("Taxa with among-taxa variarion >= 99% at ",TaxlevelTest," level.
            Inspect ",further_potential_errors," for further details and to manually flag accessions")
    
    if(length(overlaps[[h]])>0){
      print(overlaps[[h]])
      
      potential.errors<-list()
        for(j in 1:length(overlaps[[h]])){
          #message(overlaps[[h]][j])
          xy<-sb[sb$origleveltest==overlaps[[h]][j],] 
          xy<-xy[xy$pident>=99,] 
          potential.errors[[j]]<-xy[xy$hitleveltest!=overlaps[[h]][j],]
        }
      
      potential.errors.out[[h]]<-do.call(rbind,potential.errors)
      potential.errors.out[[h]]$level<- TaxlevelTest
    } else {
      message("No further potential errors found")
      potential.errors.out[[h]]<-NULL
    }
    

  #plot
  newtablong<-reshape2::melt(newtab[,c("taxon","max_within","min_within","max_among","min_among")],id.vars="taxon")
  
  #plot limit
  if(!is.null(plot.limit.taxon)) {
    before<-nrow(newtablong)
    
    #generate taxa list
    taxa.list<-list()
    for(k in 1:length(plot.limit.taxon)){
      taxa.list[[k]]<-unique(grep(plot.limit.taxon[k],newtablong$taxon,value = T))
    }
    taxa.list.to.use<-do.call(c,taxa.list)
    
    newtablongtemp<-newtablong[newtablong$taxon %in% taxa.list.to.use,]
    after<-nrow(newtablongtemp)
    if(before>0 & after==0) {
      message("No overlaps remaning after plot.limit.taxon at this level, reverting to entire plot")
    } else newtablong<-newtablongtemp
  }
  
   
    newtablong$groups<-""
    newtablong$groups[newtablong$variable=="max_within" | newtablong$variable=="min_within"]<-paste("within",TaxlevelTest,"range")
    newtablong$groups[newtablong$variable=="max_among" | newtablong$variable=="min_among"]<-paste("among",TaxlevelTest,"range")
    
    plota<-ggplot(newtablong,aes(x = taxon,y = value,colour=groups,group=interaction(taxon,groups)))+geom_point()+
      theme(axis.text.x=element_text(size=8,angle=45, hjust=1),legend.title = element_blank(),
            panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.background = element_blank(),
            axis.line = element_line(colour = "black"))+
      geom_line()+ylab("Percentage identity")+xlab("")
    
    #counts. 
    values<-seq(100,50,-1)
    res<-data.frame(pident=values,nTaxaWithin=0,nTaxaAmong=0)
    for(i in 1:length(values)){
      xx<-newtablong[newtablong$value>=values[i],]
      res[i,"nTaxaWithin"]<-length(unique(xx[grep("within",xx$groups),"taxon"])) 
      res[i,"nTaxaAmong"]<-length(unique(xx[grep("among",xx$groups),"taxon"]))
    }
    
    #plot res
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt$nTaxa<-resmelt$value
    
    plotb<-ggplot(resmelt,aes(x = pident,y = nTaxa,colour=variable))+geom_point()
      
    res$percent_among<-res$nTaxaAmong/res$nTaxaWithin*100
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt<-resmelt[resmelt$variable=="percent_among",]
    resmelt$percent_among<-resmelt$value
    
    plotc<-ggplot(resmelt,aes(x = pident,y = percent_among))+geom_point()
    
    #table of perc_within
    resx<-res[res$pident %in% c(100,99,98,97,96,95,90,85,80,75,70,65,60,50),]
    resx$percent_among<-round(resx$percent_among,digits = 0)
    perc_among_res[[h]]<-resx
    
    plot.list.loop[[1]]<-plota
    plot.list.loop[[2]]<-plotb
    plot.list.loop[[3]]<-plotc
    plot.list.all[[h]]<-plot.list.loop
  } #end h-loop
  
  #gather all potential errors and save in file
  if(length(potential.errors.out)>0){
    potential.errors.out<- do.call(rbind,potential.errors.out)
    potential.errors.out<-potential.errors.out[,c("origseqid","hitseqid", "pident" ,"origpath","hitpath","level","origseq","hitseq")]
    
    #remove multiple entries at different taxonomic levels
    ##Assumes heirarchy is followed top down
    potential.errors.out.list<-list()
    for(i in 1:length(unique(potential.errors.out$origseqid))){
      current<-unique(potential.errors.out$origseqid)[i]
      potential.errors.out.temp<-potential.errors.out[potential.errors.out$origseqid==current,]
      if(length(unique(potential.errors.out.temp$level))>1) {
        potential.errors.out.list[[i]]<-potential.errors.out.temp[potential.errors.out.temp$level==unique(potential.errors.out.temp$level)[1],]
      } else potential.errors.out.list[[i]]<-potential.errors.out.temp
    }
    
    potential.errors.out<-do.call(rbind,potential.errors.out.list)
    
    write.table(potential.errors.out,paste0(outDir,further_potential_errors),row.names=F,quote=F,sep="\t")
  }
  
  #plots
  for(h in 1:length(hierarchy)){
    print(plot.list.all[[h]][[1]])  
    print(plot.list.all[[h]][[2]])  
    print(plot.list.all[[h]][[3]])  
  }
  
  message("The following tables indicate, for each % threshold, the number of times that taxa from different families/genera/species are within the threshold (nTaxaAmong)")
  
  for(h in 1:length(hierarchy)){
    message("Level=",hierarchy[h])
    if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
    print(perc_among_res[[h]])
  }
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("calculating barcode gaps in ",t3," mins")
  
} else message("This step was not set to run")
    
```

# Calculate binning thresholds
## This runs a loop blast and a loop binning to see how many correct assignations we get under different scenarios
## Loop blast means: for each query run a blast against all other sequences in the results, except for the query species. i.e. do we get the correct genus if the species is not in the database. Simialrly, do we get the correct family when the family is not in the database
## Outputs
### Plots of the binning results classified as:
#### no_hits (no hits when taxon was removed)
#### correct (the bin taxon path matches identically the query taxon path)
#### above (the bin taxon path was assigned at a higher taxonomic level than the one being tested)
#### incorrect (the bin taxon was at the correct taxonomic level but was assigned to a different taxon that the original tacon path)
#### failed (did not pass binning thresholds / lowest common ancestor was above kingdom)
### The plots can be limited to specific taxa of interest and can be summarised at any desired taxonomic level 
```{r thresherblast, eval=TRUE,echo=F,fig.height=12,fig.width=10,results='hide'}
 #STEP4 thresher
if("thresher" %in% steps) {
  t1<-Sys.time()
  if("threshblast" %in% threshersteps){
  
  #read selfblastresults
    sb<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
    
    if(use_flagged_accessions_mbk) {
      message("Removing newly flagged accessions")
    
      flagged<-data.table::fread(paste0(outDir,flagged_accessions),data.table = F,header = F)
      sb<-sb[!sb$origseqid %in% flagged$V1,]
      sb<-sb[!sb$hitseqid %in% flagged$V1,]
    } else message("Not removing newly flagged accessions")
      
    #remove known flags
      if(!is.null(known_flags)) {
        message("Removing known flagged accessions")
        kf<-data.table::fread(known_flags,data.table = F,header = F)
        sb<-sb[!sb$origseqid %in% kf$V1,]
        sb<-sb[!sb$hitseqid %in% kf$V1,]
      } else message("Not removing any known_flags")
    
    hierarchy<-c("K","P","C","O","F","G","S")

#how about just remove all the non-species level entries and go from there, easier
sb$origtax<-stringr::str_split(sb$origpath,";",simplify = T)[,7]
sb$hittax<-stringr::str_split(sb$hitpath,";",simplify = T)[,7]

sb<-sb[sb$origtax!="unknown",]
sb<-sb[sb$hittax!="unknown",]

message("Removing species with 'sp.', numbers or more than one space")

if(length(grep(" sp\\.",sb$origtax,ignore.case = T))>0) sb<-sb[-grep(" sp\\.",sb$origtax,ignore.case = T),]
if(length(grep(" .* .*",sb$origtax,ignore.case = T))>0) sb<-sb[-grep(" .* .*",sb$origtax,ignore.case = T),]
if(length(grep("[0-9]",sb$origtax))>0) sb<-sb[-grep("[0-9]",sb$origtax),]

if(length(grep(" sp\\.",sb$hittax,ignore.case = T))>0) sb<-sb[-grep(" sp\\.",sb$hittax,ignore.case = T),]
if(length(grep(" .* .*",sb$hittax,ignore.case = T))>0) sb<-sb[-grep(" .* .*",sb$hittax,ignore.case = T),]
if(length(grep("[0-9]",sb$hittax))>0) sb<-sb[-grep("[0-9]",sb$hittax),]

#remove crappy hits 

message("Removing species containing the terms: uncultured, environmental, 
            unidentified,fungal, eukaryote, unclassified, synthetic")

crap<-c("uncultured","environmental","unclassified","unidentified","fungal ","eukaryote","synthetic")

for(i in 1:length(crap)){
  if(length(grep(crap[i],sb$origtax,ignore.case = T))>0) sb<-sb[-grep(crap[i],sb$origtax,ignore.case = T),]
  if(length(grep(crap[i],sb$hittaxid,ignore.case = T))>0) sb<-sb[-grep(crap[i],sb$hittaxid,ignore.case = T),]
}

lineage<-as.data.frame(stringr::str_split(sb$hitpath,";",simplify = T))
colnames(lineage)<-c("K","P","C","O","F","G","S")

sb<-sb[,c("origseqid","origtaxid","hitseqid", "pident","hittaxid","origpath","origseq")]
colnames(sb)<-c("qseqid","origtaxid","saccver", "pident","taxids","origpath","origseq")
sb<-cbind(sb,lineage)
sb$origgenus<-stringr::str_split(sb$origpath,";",simplify = T)[,6]
sb$origspecies<-stringr::str_split(sb$origpath,";",simplify = T)[,7]
sb$qseqid<-paste0(sb$qseqid,"_S")

sbforpaths<-sb[!duplicated(sb$qseqid),c("qseqid","origpath")]
  
TaxlevelTest=c("S","G","F")
setwd(outDir)
for(h in 1:length(TaxlevelTest)){
  #genus should be, for each query remove the hits to the same species
  #family should be, for each query remove hits to same genus
  
  if(TaxlevelTest[h]=="G") {
    threshold.bin.blast2(df = sb,TaxlevelTest = "G",qseqidcol = "qseqid",qseqcol = "origseq",taxidcol = "origtaxid")
    sb.tbbG<-data.table::fread("tempBLASTDB.G.tsv",data.table = F)
    sb.tbbG<-add.lineage.df(sb.tbbG,ncbiTaxDir = ncbiTaxDir) #for metabin
    sb.tbbG<-merge(sb.tbbG,sbforpaths,all.x=T,all.y = F,by = "qseqid")
    sb.tbbG$origgenus<-stringr::str_split(sb.tbbG$origpath,";",simplify = T)[,6]
    sb.tbbG$origspecies<-stringr::str_split(sb.tbbG$origpath,";",simplify = T)[,7]
    sb.tbbG$origseq<-sb.tbbG$qseq
    sb.tbbG<-sb.tbbG[,c("qseqid","saccver","pident","taxids", "origpath","origseq", "K","P","C" ,"O","F","G","S","origgenus","origspecies")]
    sb.tbbG$qseqid<-gsub("_S$","_G",sb.tbbG$qseqid)
  }
  
  if(TaxlevelTest[h]=="F") {
    threshold.bin.blast2(df = sb,TaxlevelTest = "F",qseqidcol = "qseqid",qseqcol = "origseq",taxidcol = "origtaxid")
    sb.tbbF<-data.table::fread("tempBLASTDB.F.tsv",data.table = F)
    sb.tbbF<-add.lineage.df(sb.tbbF,ncbiTaxDir = ncbiTaxDir)
    sb.tbbF<-merge(sb.tbbF,sbforpaths,all.x=T,all.y = F,by = "qseqid")
    sb.tbbF$origgenus<-stringr::str_split(sb.tbbF$origpath,";",simplify = T)[,6]
    sb.tbbF$origspecies<-stringr::str_split(sb.tbbF$origpath,";",simplify = T)[,7]
    sb.tbbF$origseq<-sb.tbbF$qseq
    sb.tbbF<-sb.tbbF[,c("qseqid","saccver","pident","taxids", "origpath","origseq", "K","P","C" ,"O","F","G","S","origgenus","origspecies")]
    sb.tbbF$qseqid<-gsub("_S$","_F",sb.tbbF$qseqid)
  }
  
  if(TaxlevelTest[h]=="S") {sb.splS<-sb[,c("qseqid","saccver","pident","taxids", "origpath","origseq", "K","P","C","O","F","G","S","origgenus","origspecies")] }
  
}

sb2<-rbind(sb.splS,sb.tbbG,sb.tbbF)

write.table(sb2,gsub(".tempBLASTDB.tsv$",".tempBLASTDBALL.tsv",paste0(outDir,selfblastout)),quote = F,row.names = F,sep = "\t")

if(file.exists("tempBLASTDB.F.tsv")) file.remove("tempBLASTDB.F.tsv")
if(file.exists("tempBLASTDB.G.tsv")) file.remove("tempBLASTDB.G.tsv")
file.remove(list.files(pattern="temp.db.*"))
file.remove(list.files(pattern="temp.seq.*"))
file.remove("ex.seqids.txt")

t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("blast threshing complete in ",t3," mins")
  }
}

```

```{r thresher, eval=TRUE,echo=F,fig.height=13,fig.width=10}
 #STEP4 thresher

#split this chunk to hide loop blast output from report
if("thresher" %in% steps) {
t1<-Sys.time()
  
  if("threshbin" %in% threshersteps){
    
    setwd(outDir)
    
    bin.thresh(blast.thresh.input=gsub(".tempBLASTDB.tsv$",".tempBLASTDBALL.tsv",paste0(outDir,selfblastout))
                ,tops=tops,pidents.list=pidents.list,known_flags = known_flags,final.table.out = paste0(outDir,final.table.out),
               SpeciesBL = SpeciesBL,GenusBL = GenusBL,FamilyBL = FamilyBL,ncbiTaxDir = ncbiTaxDir)
  } 
  
if("threshplots" %in% threshersteps) {
  
  plot.thresh(thresher.final.table = paste0(outDir,final.table.out),limit.plot.to.taxon = limit.plot.to.taxon,plot.at.level = plot.at.level)

  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("threshing complete in ",t3," mins")
}
  
} else message("This step was not set to run")
```