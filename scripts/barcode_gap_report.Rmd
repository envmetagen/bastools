---
title: "Plotting barcode gaps from self-blast results"
html_notebook: default
subtitle: ''
classoption: portrait
output: html_document
includes:  
      #in_header: rmarkdownsettings.txt
      extra_dependencies: ["float"]
---
# Prerequisites. The input is the results of a "thorough" blast against a large database, ideally nt
## e.g. blastn -query my.fasta -db nt -outfmt '6 qseqid saccver staxid pident sseq' -evalue 1 -max_target_seqs 50 -max_hsps 1 -word_size 11 -perc_identity 50 -qcov_hsp_perc 98 -gapopen 0 -gapextend 2 -reward 1 -penalty -1 -dust no -out my.blast.tsv
## In any case I recommend such settings, although it takes longer, as they are much more informative and useful for metabarcoding.
```{r load functions, eval=TRUE, results='hide',echo=F}
knitr::opts_chunk$set(fig.pos = "!H", out.extra = "")
source(paste0(bastoolsDir,"master_functions.R"))
library(ggplot2)
library(tidyverse)
options(httr_oob_default = TRUE)
all.stats<-list()

read.and.format.full.blast<-function(input,known_flags=NULL,rm.low.read.queries=0.90){
  #rm.low.read.queries means remove queries where size (in qseqid) < quantile 90% e.g. 90% of reads might have 35 reads or more
  
  require(stringr)
  
  #read full blast results
  fullblast<-data.table::fread(input,data.table=F, select = c("saccver","taxids","pident","sseq","qseqid")) #qseqid only for read size
  
    #remove hits to low abundance reads
  if(!is.null(rm.low.read.queries)) {
  fullblast$otu_sizes<-as.numeric(stringr::str_split(fullblast$qseqid,"size=",simplify = T)[,2])
  cutoff<-quantile(fullblast$otu_sizes,rm.low.read.queries)
  fullblast<-fullblast[fullblast$otu_sizes>=cutoff,]
  message("Not testing queries that had a read count less than ",cutoff," (quantile=",rm.low.read.queries*100,"%)")
  }
  
  #remove known flags
  if(!is.null(known_flags)) {
    message("Removing hits to known flags")
    if(!file.exists(known_flags)) stop(known_flags,"not found")
    before<-length(unique(fullblast$saccver))
    kf<-data.table::fread(known_flags,data.table = F,header = F)
    fullblast<-fullblast[!fullblast$saccver %in% kf$V1,]
    message(before-length(unique(fullblast$saccver))," hits removed")
  }
    
  #remove hyphens sseq
  fullblast$sseq<-gsub("-","",fullblast$sseq)
  
  #need to reduce db size. not sure of best option!
  ##currently- using the saccver that had the best hit in original blast, but only keep 10 per taxid maximum
  fullblast<-fullblast[order(fullblast$pident,decreasing = T),]
  fullblast<-fullblast[!duplicated(fullblast$saccver),] 
  #limit to max 10 per taxid to overcome the "thunnus issue" (having 100s of hits to one taxon)
  fullblast_spl<-split(fullblast,fullblast$taxids)
  for(i in 1:length(fullblast_spl)){
    if(nrow(fullblast_spl[[i]])>10) fullblast_spl[[i]]<-fullblast_spl[[i]][1:10,]
  }
  #keep best hit per saccver=22050
  #keep best per saccver, but only those that had >70% pidents=16390, 80%=9483
  #keep best hit per sseq=29796
  #keep best hit per staxid=9419, 
  #if then only keeping unique sseqs->7953 (could then map results back later,but I have not implemented this)
  #keep best hit per species=8765 (think this is not ideal)
  
  fullblast<-do.call(rbind,fullblast_spl)
  
  rm(fullblast_spl)
  
  #make new header names with taxids, for building db
  fullblast$seq.name<-paste0(fullblast$saccver," taxid=", fullblast$taxids,"; ")
  
  #add seq.text, for phylotools
  fullblast$seq.text<-fullblast$sseq 
  
  #add lineages for later
  fullblast<-add.lineage.df(fullblast,ncbiTaxDir)
  fullblast$origpath<-paste(fullblast$K,fullblast$P,fullblast$C,fullblast$O,fullblast$F,fullblast$G,fullblast$S,sep=";")
  
  fullblast<-fullblast[,c("saccver","taxids","seq.name","seq.text","origpath")]
  
  colnames(fullblast)<-c("origseqid","origtaxid","seq.name","seq.text","origpath")
  
  return(fullblast)
} 
```

## STEP1 SELF BLAST
### Convert the sseqs into a blast database, select all saccvers that had >80% identity. Output a krona plot of the database, to see what is in it
```{r self blast, eval=TRUE,echo=F}

if("selfblast" %in% steps) {
  
  t1<-Sys.time()
  
  fullblast<-read.and.format.full.blast(input) 
  
  #MAKE KRONA OF DB
  x<-as.data.frame(table(fullblast$origpath))
  colnames(x)<-c("taxon","count")
  bas.krona.plot(taxatable = x,out = paste0(outDir,krona_html_db),KronaPath = KronaPath)
  message("krona plot for self-blast database saved to ", paste0(outDir,krona_html_db))
  
  #make fasta of DB
  phylotools::dat2fasta(fullblast[,c("seq.name","seq.text")],paste0(outDir,"tempBLASTDB.fasta"))
  
  #make blastdb using metabinkit
  system2("metabinkit_blastgendb",c("-f",paste0(outDir,"tempBLASTDB.fasta"),"-o", paste0(outDir,"tempBLASTDB"),"-c"),wait = T)
  
  message("straight SELF-BLAST running...")
  
  if(!exists("divergence")) {
    divergence<-rep(5,length(TaxlevelTestall))
    message("Defaulting to divergence of 5 for all levels")
  }
  
  perc_identity<-98-max(divergence)-5 #adding the minus 5 just to catch a few more hits, 98 because this is what I use later to say there were "high" hits
  
  message("word_size set to 20. This was tested for a fragment of c. 105bp and did not result in many fewer hits than word_size of 11 (word_size 28 did), but if testing a shorter fragment consider revising")
  
  argsblast=c("-task","megablast", "-query", paste0(outDir,"tempBLASTDB.fasta"), "-db",paste0(outDir,"tempBLASTDB"),"-outfmt",
                 "'6 qseqid saccver staxid pident sseq'","-evalue",1,"-num_threads", 64, "-max_target_seqs", 
                 500, "-max_hsps",1,"-word_size", 20,"-perc_identity", perc_identity,"-qcov_hsp_perc",98,
                 "-gapopen", 0, "-gapextend", 2, "-reward", 1, "-penalty", -1, "-dust","no", "-out", 
                 paste0(outDir,selfblastout))
  
  message(argsblast)
  
  system2(command = "blastn",args=argsblast, wait = T)
  
  headers<-paste0("'1i",paste(c("origseqid", "hitseqid", "hittaxid", "pident","hitseq"),collapse = "\t"),"'")
  
  system2("sed",c("-i", headers, paste0(outDir,selfblastout)),wait = T)
  
  #combine all necessary info and output single table
  ##read self-blast
  sb<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
  #remove hyphens sseq
  sb$hitseq<-gsub("-","",sb$hitseq)
  
  #add hit path
  sb<-add.lineage.df(sb,ncbiTaxDir,taxCol = "hittaxid")
  sb$hitpath<-paste(sb$K,sb$P,sb$C,sb$O,sb$F,sb$G,sb$S,sep=";")
  sb<-sb[,c("origseqid", "hitseqid", "hittaxid", "pident","hitseq","hitpath")]
  
  ##add origpath and origseq to selfblast
  sb<-merge(sb,fullblast[,c("origseqid","origtaxid", "origpath","seq.text")], by="origseqid",all.x = T,all.y = F)
  colnames(sb)<-gsub("seq.text","origseq",colnames(sb))
  sb<-sb[,c("origseqid","hitseqid","pident","origtaxid","hittaxid", "origpath","hitpath","origseq","hitseq")] #seq.text=origseq
  
  rm(fullblast)
  
  write.table(sb,paste0(outDir,selfblastout),quote = F,row.names = F,sep = "\t")
  
  #remove tempdb
  file.remove(list.files(pattern = "tempBLASTDB.n.*"))
  file.remove("tempBLASTDB.fasta")
  file.remove("tempBLASTDB.taxid_map.tsv")
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("self-blast complete in ",t3," mins")
  
} else message("This step was not set to run")

```

## find_db_errors
### For each taxonomic level (F,G,S) look for potentially misassigned entries (see output for rules). Output a table of the results for manual inspection
### So far haven seen any flagged accessions that seem incorrectly flagged. But not all errors are caught. Main case is when there are multiple erroneously labelled entries of the same taxon. 
```{r find_db_errors, eval=TRUE,echo=F}
if("find_db_errors" %in% steps) {
  
  ##TODO outputting the specific reasons fo passing in the output would help, particularly for the bc output 
  
  t1<-Sys.time()

  allerrors<-list()
  allflagged<-list()
  ax_exflagged<-list()
  
  #read selfblastresults
  sb<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
  
  before<-length(unique(sb$origseqid))
  
  sbtemp<-sb
  
  #remove XM_,XR_,XP_ accessions These are 'PREDICTED' in-silico generated
  message("excluding 'PREDICTED', in-silico generated, accessions")
  if(length(grep("XM_.*",sb$origseqid))>0) sb<-sb[-grep("XM_.*",sb$origseqid),] 
  if(length(grep("XR_.*",sb$origseqid))>0) sb<-sb[-grep("XR_.*",sb$origseqid),] 
  if(length(grep("XP_.*",sb$origseqid))>0) sb<-sb[-grep("XP_.*",sb$origseqid),] 
  if(length(grep("XM_.*",sb$hitseqid))>0) sb<-sb[-grep("XM_.*",sb$hitseqid),] 
  if(length(grep("XR_.*",sb$hitseqid))>0) sb<-sb[-grep("XR_.*",sb$hitseqid),] 
  if(length(grep("XP_.*",sb$hitseqid))>0) sb<-sb[-grep("XP_.*",sb$hitseqid),] 
  
  message("'PREDICTED' in-silico sequences removed:",before-length(unique(sb$origseqid)))
  removed.accs<-sbtemp[!sbtemp$origseqid %in% unique(sb$origseqid),]
  removed.accs<-removed.accs[!duplicated(removed.accs$origseqid),c("origseqid","origpath")]
  print(removed.accs)
  
  rm(sbtemp)
    
  #remove known flags
  if(!is.null(known_flags)) {
    beforeaccs<-unique(sb$origseqid)
    before<-length(beforeaccs)
    kf<-data.table::fread(known_flags,data.table = F,header = F)
    sb<-sb[!sb$origseqid %in% kf$V1,]
    sb<-sb[!sb$hitseqid %in% kf$V1,]
    message("Known flagged sequences removed:",before-length(unique(sb$origseqid)))
    print(kf$V1)
  }
  
  #loop by taxa level (FGS), fnding errors for each level
  hierarchy<-c("K","P","C","O","F","G","S")
  
  if(!exists("divergence")) {
    divergence<-rep(5,length(TaxlevelTestall))  ##TODO change this if extending to other levels
    message("Defaulting to divergence of 5 for all levels")
  }
    
  #if 5 then a query will fail if the genus is not present within 5% identity of the top hit, but how to choose? 
  #could vastly speed this up bydoing species first and onyl testing those that failed at genus and family
  #now that Iá¸¿ going to kpco levels, this is more nb
  for(h in 1:length(TaxlevelTestall)){
    
    if(h>1) sb<-sbtemp
    
    TaxlevelTest<-TaxlevelTestall[h]
    
    message("finding errors in database using taxlevel ",TaxlevelTest)
  
    #limit to taxleveltest not unknown for both origpath and hitpath (i.e. both must have taxonomy at this level)
    ##make split taxonomy
    sb$origtax<-stringr::str_split(sb$origpath,";",simplify = T)[,match(TaxlevelTest,hierarchy)]
    sb$hittax<-stringr::str_split(sb$hitpath,";",simplify = T)[,match(TaxlevelTest,hierarchy)]
    
    sb<-sb[sb$origtax!="unknown",]
    sb<-sb[sb$hittax!="unknown",]
    
    #if TaxlevelTest[i]="S" remove sp.-type entries, from both orig and hit  
    if(TaxlevelTest=="S"){
      message("Removing species with 'sp.', numbers or more than one space")
      
       if(length(grep(" sp\\.",sb$origtax,ignore.case = T))>0) sb<-sb[-grep(" sp\\.",sb$origtax,ignore.case = T),]
       if(length(grep(" .* .*",sb$origtax,ignore.case = T))>0) sb<-sb[-grep(" .* .*",sb$origtax,ignore.case = T),]
       if(length(grep("[0-9]",sb$origtax))>0) sb<-sb[-grep("[0-9]",sb$origtax),]
      
       if(length(grep(" sp\\.",sb$hittax,ignore.case = T))>0) sb<-sb[-grep(" sp\\.",sb$hittax,ignore.case = T),]
       if(length(grep(" .* .*",sb$hittax,ignore.case = T))>0) sb<-sb[-grep(" .* .*",sb$hittax,ignore.case = T),]
       if(length(grep("[0-9]",sb$hittax))>0) sb<-sb[-grep("[0-9]",sb$hittax),]

      #remove crappy hits 
       
       message("Removing species containing the terms: uncultured, environmental, 
            unidentified,fungal, eukaryote, unclassified, synthetic")
       
       crap<-c("uncultured","environmental","unclassified","unidentified","fungal ","eukaryote","synthetic")
       
       for(i in 1:length(crap)){
         if(length(grep(crap[i],sb$origtax,ignore.case = T))>0) sb<-sb[-grep(crap[i],sb$origtax,ignore.case = T),]
         if(length(grep(crap[i],sb$hittaxid,ignore.case = T))>0) sb<-sb[-grep(crap[i],sb$hittaxid,ignore.case = T),]
       }
    }
   
    #order
    sb<-sb[order(sb$pident,decreasing = T),]
    
    #add path of current level
    sb$origleveltest<-path.at.level(sb$origpath,TaxlevelTest)
    sb$hitleveltest<-path.at.level(sb$hitpath,TaxlevelTest)
     
    ###filterA
    sb.list<-split(sb,sb$origseqid)
    sbtemp<-sb
    errors<-list()
    
    for(i in 1:length(sb.list)){
      
      #      if(sb.list[[i]]$origseqid[1]=="DQ485816.1") stop(i)
       #    }
      outcome<-"failed"
      
      #remove self-hit
      xx<-sb.list[[i]][sb.list[[i]]$hitseqid!=sb.list[[i]]$origseqid[1],]
      
      #if no other hits, cannot fail
      if(nrow(xx)==0) outcome<-"passed"
      
      #human test
      if(outcome=="failed") {
        #still assigns other primates as likely human, skip primates
        if(length(grep("Eukaryota;Chordata;Mammalia;Primates",xx$origpath[1]))!=1) {
          if("Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens" %in% xx$hitpath) {
            if(max(xx[xx$hitpath=="Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens","pident"])>98) outcome<-"human"
          }
        }
      }
      
      #an issue here. if max_target_seqs was too low in original blast then all hits might be above e.g. 99% and we might not have hits to other members of the taxon, even though they are very similar. then will be incorrectly flagged. So can only fail if we have "distant" hits in our results.
      
      #apply a top value, e.g. 10%. otherwise our query family is likely to be in results, even though many closer hits
      #but should know what the lowest contains 10% divergence (i.e. that full results didnt only go to e.g. 96%), if it does not then pass it
      if(outcome=="failed") if(min(xx$pident)>max(xx$pident)-divergence[h]) outcome<-"passed" 
      if(outcome=="failed") xx<-xx[xx$pident>=max(xx$pident)-divergence[h],] 
      
      #all other hits belong to other families only
      if(outcome=="failed") if(xx$origleveltest[1] %in% xx$hitleveltest) outcome<-"passed"
      
      #remaining families contain a high hit (e.g. 98%)
      if(outcome=="failed" | outcome=="human") if(max(xx$pident)<98) outcome<-"passed"
          
      #if database doesnt contain at least 3 other representatives of the taxon, then pass it. If it does contain 3 other representatives then fail it, but only if other representatives have at least 3 sequences that are within 2% of query length (otherwise they wont be in blast results and can be erroneously flagged)
      if(outcome=="failed") {
        
        if(length(unique(sbtemp[sbtemp$origleveltest==xx$origleveltest[1],"origseqid"]))>3) { 
          qlen<-nchar(xx$origseq[1])
          minslen<-round(qlen*0.981,digits = 0) #just adding to one to be sure it is above
          seqs.in.group<-sbtemp[sbtemp$origleveltest==xx$origleveltest[1],c("origseqid", "origseq")]
          seqs.in.group<-seqs.in.group[!duplicated(seqs.in.group$origseqid),]
          seqs.in.group<-seqs.in.group[!seqs.in.group$origseqid==xx$origseqid[1],]
          slens<-nchar(seqs.in.group$origseq)
          slens<-slens[slens>=minslen]
          
          if(length(slens)<3) outcome<-"passed" 
        
        } else outcome<-"passed"
      }
  
     if(outcome=="failed" | outcome=="human") {
        errors[[i]]<-sb.list[[i]]
        current<-sb.list[[i]]$origseqid[1]
        if(outcome=="failed") {
          message(current," failed_A ",TaxlevelTestall[h]," ",xx$origleveltest[1],"
          ",xx$origseq[1])
          errors[[i]]$reason<-"filterA"
          errors[[i]]$taxlevel<-TaxlevelTestall[h]
        }
        if(outcome=="human") {
          message(current," failedHu - possible human ",TaxlevelTestall[h]," ",xx$origleveltest[1],"
          ",xx$origseq[1])
          errors[[i]]$reason<-"filterHu"
          errors[[i]]$taxlevel<-TaxlevelTestall[h]
        }
        #remove from db before next loop.
        sb.list<-lapply(sb.list,function(x) x<-x[x$hitseqid!=current,]) #this will be reused within this i loop
        sbtemp<-do.call(rbind,sb.list) #sbtemp will be carried to filterB
        sbtemp<-sbtemp[sbtemp$origseqid!=current,]
      } else errors[[i]]<-NULL
    } #end of i
    
    #h
    
    #collate errors
    errors<-errors %>% discard(is.null)
    
    if(length(errors)>0) {
      errors<-do.call(rbind,errors)
      errors<-errors[,c("origseqid","hitseqid" ,"pident","origleveltest","hitleveltest","reason","taxlevel","origseq","hitseq")]
      flagged<-unique(errors$origseqid)
    } else {
      errors<-NULL
      flagged<-NULL
    }
    
    #FILTER_B
    #second filter based on hits rather than queries. if a hitpath is NEVER the same as the origpath (despite multiple queries matching that hit), likely an error
    #AND there were high hits
    #AND there at least three other members of the taxonlevel in the database
    
    sb.list<-split(sbtemp,sbtemp$hitseqid)
    errorsB<-list()
    for(i in 1:length(sb.list)){
      
     #  if(sb.list[[i]]$hitseqid[1]=="AC197159.2") stop(i)
      #}
    
    outcome<-"failed"
    current<-unique(sb.list[[i]]$hitseqid)[1]
    currenttax<-sb.list[[i]]$hitleveltest[1]
    
    yy<-sb.list[[i]][sb.list[[i]]$origseqid!=current,]
        
    if(nrow(yy)==0) outcome<-"passed"
    
     #apply a top value, e.g. 10%. otherwise our query family is likely to be in results, even though many closer hits
      #but should know what the lowest contains 10% divergence (i.e. that full results didnt only go to e.g. 96%), if it does not then pass it
    if(outcome=="failed") if(min(yy$pident)>max(yy$pident)-divergence[h]) outcome<-"passed" 
    
    if(outcome=="failed") yy<-yy[yy$pident>=max(yy$pident)-divergence[h],] 
    
    if(outcome=="failed") if(yy$hitleveltest[1] %in% yy$origleveltest) outcome<-"passed" 
      
    if(outcome=="failed") if(max(yy$pident)<98) outcome<-"passed" 
    
      #if database doesnt contain at least 3 other representatives of the taxon, then pass it. If it does contain 3 other representatives then fail it, but only if other representatives have at least 3 sequences that are within 2% of query length (otherwise they wont be in blast results and can be erroneously flagged)
    if(outcome=="failed") if(length(unique(sbtemp[sbtemp$origleveltest==currenttax,"origseqid"]))>3) { 
          sseq<-sbtemp[sbtemp$origseqid==current,"origseq"][1]
          slen<-nchar(sseq)
          maxqlen<-round(slen*1.0199,digits = 0) #just minusing the one to be sure it is below
          seqs.in.group<-sbtemp[sbtemp$origleveltest==currenttax,c("origseqid", "origseq")]
          seqs.in.group<-seqs.in.group[!duplicated(seqs.in.group$origseqid),]
          seqs.in.group<-seqs.in.group[!seqs.in.group$origseqid==current,]
          qlens<-nchar(seqs.in.group$origseq)
          qlens<-qlens[qlens<=maxqlen]
          if(length(qlens)<3) outcome<-"passed" 
        } else outcome<-"passed"
    
    
      #if all hits remaining from an entry are NEVER the same as the origpath, and there were high hits then fail
        if(outcome=="failed") {
          errorsB[[i]]<-yy 
          message(current," failed_B ",TaxlevelTestall[h]," ",yy$hitleveltest[1],"
          ",sseq)
          errorsB[[i]]$reason<-"filterB"
          errorsB[[i]]$taxlevel<-TaxlevelTestall[h]
          #remove from db before next loop.  
          sb.list<-lapply(sb.list,function(x) x<-x[x$origseqid!=current,]) #this will be reused within this i loop
          sbtemp<-do.call(rbind,sb.list) #sbtemp will be carried to next h loop
          sbtemp<-sbtemp[sbtemp$hitseqid!=current,]
        } else errorsB[[i]]<-NULL
    
    } #end of i
   
    #h
       
    errorsB<-errorsB %>% discard(is.null)
    if(length(errorsB)>0) {
      errorsB<-do.call(rbind,errorsB)
      errorsB<-errorsB[order(errorsB$hitseqid,errorsB$pident,decreasing = T),]
      errorsB<-errorsB[,c("origseqid","hitseqid" ,"pident","origleveltest","hitleveltest","reason","taxlevel","origseq","hitseq")]
      flaggedB<-unique(errorsB$hitseqid)
    } else   {
      flaggedB<-NULL
      errorsB<-NULL
    }
    
    #combine filter results within h loop
    allerrors[[h]]<-rbind(errors,errorsB)
    allflagged[[h]]<-c(flagged, flaggedB)
  } #end h
  
  #should start with lowest taxon level (e.g. genus) and move uowards after each loop, should only 1) repeat those that failed to see if they fail at higher level 2) do those that werent included in previous rounds. will be much faster
  
  #combine results for all taxon loops
  allerrorsdf<-do.call(rbind,allerrors) 
  allflagged<-do.call(c,allflagged)
  if(length(removed.accs$origseqid)>0) allflagged<-unique(c(removed.accs$origseqid,allflagged))
  
  write.table(allflagged,paste0(outDir,flagged_accessions),row.names = F,quote = F,sep = "\t",col.names = F)
  write.table(allerrorsdf,file = paste0(outDir,flagged_error_detailed_table),quote = F,sep = "\t",row.names = F)

  message("Note: The filter will run at each taxonomic level specified. 
          
          Explanation of filters: 
  
          filterA: Indicates query was flagged because
           All hits within specified 'divergence' of the best hit belonged to a different taxon at this taxlevel  
            AND there was at least one hit >98%
             AND there were at least three other members of the taxon in the database (i.e. it is reasonably represented)
              AND at least three of the sequences of the other members were a similar length (98% qcov) 
                
          filterHu (a special case of filterA): Indicates qseqid was flagged because
           It was not an entry designated as a primate, but has a hit >98% matching  
           Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens
           
          FilterB: Indicates a subject was flagged because
            All queries within specified 'divergence' of the best hit match to this subject belonged to a different taxon at this taxlevel
              AND there were high hits >98%
                AND there were at least three other members of the taxon in the database (i.e. it is reasonably represented)
                 AND at least three of the sequences of the other members were a similar length (98% qcov) 
           ")
  
  message("newly flagged accession numbers")
  print(as.data.frame(allflagged))
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("finding errors complete in ",t3," mins")
  
} else message("This step was not set to run")
```

# calc_bar_gap
## basically, plot the blast results indicating the within-taxon variation vs among-taxon variation at F, G & S levels to help to choose appropriate binning thresholds.
## What we want to use in the end is the lowest %identity (to limit our loss of reads assigned at each level) that excludes other taxa (to increase resolution). In practice this is a trade-off because we often get overlap of within-taxon variation and among-taxon variation. Feeding these % identities to metabinkit (lca approach), we will never get "wrong" results (unless we still have database errors), but we will just lose resolution if the % identity is too low OR too high. E.g. if species threshold is 95% (caseA), many queries will have hits to multiple species and wont be binned at species-level, but if species threshold is 100% (caseB) many queries will have no hits passing this filter and so also wont be binned at species-level. CaseA can be partially overcome by applying a low "Top.." value.  E.g. if species threshold is 95% but a Top of 1% has been applied, then there will not be as many hits surviving the filters and we will get higher numbers of queries at species-level. How to choose tops? Is using a low top always ok?
```{r calc_bar_gap, eval=TRUE,echo=F,fig.height=7,fig.width=10}
 #STEP3 calculate barcoding gaps
if("calc_bar_gap" %in% steps) {
  
  t1<-Sys.time()
  
  if(!is.null(plot.limit.taxon)) message("Limiting plots to ",plot.limit.taxon)
  
    #read selfblastresults
    sbo<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
    
    if(use_flagged_accessions_bcg) {
      message("Removing newly flagged accessions")
    
      flagged<-data.table::fread(paste0(outDir,flagged_accessions),data.table = F,header = F)
      sbo<-sbo[!sbo$origseqid %in% flagged$V1,]
      sbo<-sbo[!sbo$hitseqid %in% flagged$V1,]
    } else message("Not removing newly flagged accessions")
      
    #remove known flags
      if(!is.null(known_flags)) {
        message("Removing known flagged accessions")
        kf<-data.table::fread(known_flags,data.table = F,header = F)
        sbo<-sbo[!sbo$origseqid %in% kf$V1,]
        sbo<-sbo[!sbo$hitseqid %in% kf$V1,]
      } else message("Not removing any known_flags")
    
  plot.list.loop<-list()
  plot.list.all<-list()
  perc_among_res<-list()
  overlaps<-list()
  potential.errors.out<-list()
  
   #loop by taxa level, plotting errors for each level
  hierarchy<-c("K","P","C","O","F","G","S")
  
  for(h in 1:length(hierarchy)){
    
    sb<-sbo
  
    TaxlevelTest<-hierarchy[h]
    
    #limit to taxleveltest not unknown
    sb$origtax<-stringr::str_split(sb$origpath,";",simplify = T)[,match(TaxlevelTest,hierarchy)]
    sb$hittax<-stringr::str_split(sb$hitpath,";",simplify = T)[,match(TaxlevelTest,hierarchy)]
    sb<-sb[sb$origtax!="unknown",]
    sb<-sb[sb$hittax!="unknown",]
    
    sb$origleveltest<-path.at.level(sb$origpath,TaxlevelTest)
    sb$hitleveltest<-path.at.level(sb$hitpath,TaxlevelTest)

    #within taxlevel vs among tax level range
    newtab<-data.frame(matrix(ncol=6,nrow = length(unique(sb$origleveltest))))
    colnames(newtab)<-c("taxon","max_within","min_within","max_among","min_among","max_among_hitseqid")
    
    sb.spl<-split(sb,sb$origleveltest)
    
    for(i in 1:length(sb.spl)){
      temp<-sb.spl[[i]]
      taxoni<-temp$origleveltest[1]
      newtab$taxon[i]=taxoni
      newtab$max_within[i]=max(temp[temp$hitleveltest==taxoni,"pident"])
      newtab$min_within[i]=min(temp[temp$hitleveltest==taxoni,"pident"])
      
      if(nrow(temp[temp$hitleveltest!=taxoni,])>0){
        newtab$max_among[i]=max(temp[temp$hitleveltest!=taxoni,"pident"])
        newtab$min_among[i]=min(temp[temp$hitleveltest!=taxoni,"pident"])
        newtab$max_among_hitseqid[i]=temp[temp$hitleveltest!=taxoni,"hitseqid"][1]
      } else {
        #stop(i)
        newtab$max_among[i]=0
        newtab$min_among[i]=0
      }
    }
    
    #print overlaps for inspection later
    overlaps[[h]]<-unique(newtab[newtab$max_among>=99,"taxon"])
    
    message("Taxa with among-taxa variarion >= 99% at ",TaxlevelTest," level.
            Inspect ",further_potential_errors," for further details and to manually flag accessions")
    
    if(length(overlaps[[h]])>0){
      print(overlaps[[h]])
      
      potential.errors<-list()
        for(j in 1:length(overlaps[[h]])){
          #message(overlaps[[h]][j])
          xy<-sb[sb$origleveltest==overlaps[[h]][j],] 
          xy<-xy[xy$pident>=99,] 
          potential.errors[[j]]<-xy[xy$hitleveltest!=overlaps[[h]][j],]
        }
      
      potential.errors.out[[h]]<-do.call(rbind,potential.errors)
      potential.errors.out[[h]]$level<- TaxlevelTest
    } else {
      message("No further potential errors found")
      potential.errors.out[[h]]<-NULL
    }
    

  #plot
  newtablong<-reshape2::melt(newtab[,c("taxon","max_within","min_within","max_among","min_among")],id.vars="taxon")
  
  #plot limit
  if(!is.null(plot.limit.taxon)) {
    before<-nrow(newtablong)
    
    #generate taxa list
    taxa.list<-list()
    for(k in 1:length(plot.limit.taxon)){
      taxa.list[[k]]<-unique(grep(plot.limit.taxon[k],newtablong$taxon,value = T))
    }
    taxa.list.to.use<-do.call(c,taxa.list)
    
    newtablongtemp<-newtablong[newtablong$taxon %in% taxa.list.to.use,]
    after<-nrow(newtablongtemp)
    if(before>0 & after==0) {
      message("No overlaps remaning after plot.limit.taxon at this level, reverting to entire plot")
    } else newtablong<-newtablongtemp
  }
  
   
    newtablong$groups<-""
    newtablong$groups[newtablong$variable=="max_within" | newtablong$variable=="min_within"]<-paste("within",TaxlevelTest,"range")
    newtablong$groups[newtablong$variable=="max_among" | newtablong$variable=="min_among"]<-paste("among",TaxlevelTest,"range")
    
    plota<-ggplot(newtablong,aes(x = taxon,y = value,colour=groups,group=interaction(taxon,groups)))+geom_point()+
      theme(axis.text.x=element_text(size=8,angle=45, hjust=1),legend.title = element_blank(),
            panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.background = element_blank(),
            axis.line = element_line(colour = "black"))+
      geom_line()+ylab("Percentage identity")+xlab("")
    
    #counts. 
    values<-seq(100,50,-1)
    res<-data.frame(pident=values,nTaxaWithin=0,nTaxaAmong=0)
    for(i in 1:length(values)){
      xx<-newtablong[newtablong$value>=values[i],]
      res[i,"nTaxaWithin"]<-length(unique(xx[grep("within",xx$groups),"taxon"])) 
      res[i,"nTaxaAmong"]<-length(unique(xx[grep("among",xx$groups),"taxon"]))
    }
    
    #plot res
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt$nTaxa<-resmelt$value
    
    plotb<-ggplot(resmelt,aes(x = pident,y = nTaxa,colour=variable))+geom_point()
      
    res$percent_among<-res$nTaxaAmong/res$nTaxaWithin*100
    resmelt<-reshape2::melt(res,id.vars="pident")
    resmelt<-resmelt[resmelt$variable=="percent_among",]
    resmelt$percent_among<-resmelt$value
    
    plotc<-ggplot(resmelt,aes(x = pident,y = percent_among))+geom_point()
    
    #table of perc_within
    resx<-res[res$pident %in% c(100,99,98,97,96,95,90,85,80,75,70,65,60,50),]
    resx$percent_among<-round(resx$percent_among,digits = 0)
    perc_among_res[[h]]<-resx
    
    plot.list.loop[[1]]<-plota
    plot.list.loop[[2]]<-plotb
    plot.list.loop[[3]]<-plotc
    plot.list.all[[h]]<-plot.list.loop
  } #end h-loop
  
  #gather all potential errors and save in file
  potential.errors.out<- do.call(rbind,potential.errors.out)
  potential.errors.out<-potential.errors.out[,c("origseqid","hitseqid", "pident" ,"origpath","hitpath","level","origseq","hitseq")]
  
  #remove multiple entries at different taxonomic levels
  ##Assumes heirarchy is followed top down
  potential.errors.out.list<-list()
  for(i in 1:length(unique(potential.errors.out$origseqid))){
    current<-unique(potential.errors.out$origseqid)[i]
    potential.errors.out.temp<-potential.errors.out[potential.errors.out$origseqid==current,]
    if(length(unique(potential.errors.out.temp$level))>1) {
      potential.errors.out.list[[i]]<-potential.errors.out.temp[potential.errors.out.temp$level==unique(potential.errors.out.temp$level)[1],]
    } else potential.errors.out.list[[i]]<-potential.errors.out.temp
  }
  
  potential.errors.out<-do.call(rbind,potential.errors.out.list)
  
  write.table(potential.errors.out,paste0(outDir,further_potential_errors),row.names=F,quote=F,sep="\t")
  
  #plots
  for(h in 1:length(hierarchy)){
    print(plot.list.all[[h]][[1]])  
    print(plot.list.all[[h]][[2]])  
    print(plot.list.all[[h]][[3]])  
  }
  
  message("The following tables indicate, for each % threshold, the number of times that taxa from different families/genera/species are within the threshold (nTaxaAmong)")
  
  for(h in 1:length(hierarchy)){
    message("Level=",hierarchy[h])
    if(!is.null(plot.limit.taxon)) message("Limited to ",plot.limit.taxon)
    print(perc_among_res[[h]])
  }
  
  t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("calculating barcode gaps in ",t3," mins")
  
} else message("This step was not set to run")
    
```

# thresher
## This run a loop blast and a loop binning to see how many correct assignations we get under different scenarios
```{r thresher, eval=TRUE,echo=F,fig.height=7,fig.width=10}
 #STEP3 calculate barcoding gaps
if("thresher" %in% steps) {
  if("threshblast" %in% threshersteps){
  
  t1<-Sys.time()
  #read selfblastresults
    sb<-data.table::fread(paste0(outDir,selfblastout),data.table = F)
    
    if(use_flagged_accessions_mbk) {
      message("Removing newly flagged accessions")
    
      flagged<-data.table::fread(paste0(outDir,flagged_accessions),data.table = F,header = F)
      sb<-sb[!sb$origseqid %in% flagged$V1,]
      sb<-sb[!sb$hitseqid %in% flagged$V1,]
    } else message("Not removing newly flagged accessions")
      
    #remove known flags
      if(!is.null(known_flags)) {
        message("Removing known flagged accessions")
        kf<-data.table::fread(known_flags,data.table = F,header = F)
        sb<-sb[!sb$origseqid %in% kf$V1,]
        sb<-sb[!sb$hitseqid %in% kf$V1,]
      } else message("Not removing any known_flags")
    
    hierarchy<-c("K","P","C","O","F","G","S")
#ok, so this is a more or less complete comparison of everything in blast database,
#can I run "fake loop blast" by just excluding results taxon by taxon?
#make fake loop blast files
#how about just remove all the non-species level entries and go from there, easier
sb$origtax<-stringr::str_split(sb$origpath,";",simplify = T)[,7]
sb$hittax<-stringr::str_split(sb$hitpath,";",simplify = T)[,7]

sb<-sb[sb$origtax!="unknown",]
sb<-sb[sb$hittax!="unknown",]

message("Removing species with 'sp.', numbers or more than one space")

if(length(grep(" sp\\.",sb$origtax,ignore.case = T))>0) sb<-sb[-grep(" sp\\.",sb$origtax,ignore.case = T),]
if(length(grep(" .* .*",sb$origtax,ignore.case = T))>0) sb<-sb[-grep(" .* .*",sb$origtax,ignore.case = T),]
if(length(grep("[0-9]",sb$origtax))>0) sb<-sb[-grep("[0-9]",sb$origtax),]

if(length(grep(" sp\\.",sb$hittax,ignore.case = T))>0) sb<-sb[-grep(" sp\\.",sb$hittax,ignore.case = T),]
if(length(grep(" .* .*",sb$hittax,ignore.case = T))>0) sb<-sb[-grep(" .* .*",sb$hittax,ignore.case = T),]
if(length(grep("[0-9]",sb$hittax))>0) sb<-sb[-grep("[0-9]",sb$hittax),]

#remove crappy hits 

message("Removing species containing the terms: uncultured, environmental, 
            unidentified,fungal, eukaryote, unclassified, synthetic")

crap<-c("uncultured","environmental","unclassified","unidentified","fungal ","eukaryote","synthetic")

for(i in 1:length(crap)){
  if(length(grep(crap[i],sb$origtax,ignore.case = T))>0) sb<-sb[-grep(crap[i],sb$origtax,ignore.case = T),]
  if(length(grep(crap[i],sb$hittaxid,ignore.case = T))>0) sb<-sb[-grep(crap[i],sb$hittaxid,ignore.case = T),]
}

lineage<-as.data.frame(stringr::str_split(sb$hitpath,";",simplify = T))
colnames(lineage)<-c("K","P","C","O","F","G","S")

###using this point as bin blast, could be earlier

sb<-sb[,c("origseqid","hitseqid", "pident","hittaxid","origpath","origseq")]
colnames(sb)<-c("qseqid","saccver", "pident","taxids","origpath","origseq")
sb<-cbind(sb,lineage)
sb$origgenus<-stringr::str_split(sb$origpath,";",simplify = T)[,6]
sb$origspecies<-stringr::str_split(sb$origpath,";",simplify = T)[,7]
sb$qseqid<-paste0(sb$qseqid,"_S")

sbforpaths<-sb[!duplicated(sb$qseqid),c("qseqid","origpath")]
  
TaxlevelTest=c("S","G","F")

for(h in 1:length(TaxlevelTest)){
  #genus should be, for each query remove the hits to the same species
  #family should be, for each query remove hits to same genus
  
  #problems with this approach, how many queries disappear because there are no hits that did not belong to that genus, looks like a lot
  #so these are not being tested at all
  
  #soooo, back to thresh blast, can I make identical output to sb2
  
  if(TaxlevelTest[h]=="G") {
    threshold.bin.blast2(df = sb,TaxlevelTest = "G",qseqidcol = "qseqid",qseqcol = "origseq",taxidcol = "taxids")
    sb.tbbG<-data.table::fread("tempBLASTDB.G.tsv",data.table = F)
    sb.tbbG<-add.lineage.df(sb.tbbG,ncbiTaxDir = ncbiTaxDir) #for metabin
    sb.tbbG<-merge(sb.tbbG,sbforpaths,all.x=T,all.y = F,by = "qseqid")
    sb.tbbG$origgenus<-stringr::str_split(sb.tbbG$origpath,";",simplify = T)[,6]
    sb.tbbG$origspecies<-stringr::str_split(sb.tbbG$origpath,";",simplify = T)[,7]
    sb.tbbG$origseq<-sb.tbbG$qseq
    sb.tbbG<-sb.tbbG[,c("qseqid","saccver","pident","taxids", "origpath","origseq", "K","P","C" ,"O","F","G","S","origgenus","origspecies")]
    sb.tbbG$qseqid<-gsub("_S$","_G",sb.tbbG$qseqid)
  }
  
  if(TaxlevelTest[h]=="F") {
    threshold.bin.blast2(df = sb,TaxlevelTest = "F",qseqidcol = "qseqid",qseqcol = "origseq",taxidcol = "taxids")
    sb.tbbF<-data.table::fread("tempBLASTDB.F.tsv",data.table = F)
    sb.tbbF<-add.lineage.df(sb.tbbF,ncbiTaxDir = ncbiTaxDir)
    sb.tbbF<-merge(sb.tbbF,sbforpaths,all.x=T,all.y = F,by = "qseqid")
    sb.tbbF$origgenus<-stringr::str_split(sb.tbbF$origpath,";",simplify = T)[,6]
    sb.tbbF$origspecies<-stringr::str_split(sb.tbbF$origpath,";",simplify = T)[,7]
    sb.tbbF<-sb.tbbF[,c("qseqid","saccver","pident","taxids", "origpath","K","P","C" ,"O","F","G","S","origgenus","origspecies")]
    sb.tbbF$origseq<-sb.tbbF$qseq
    sb.tbbF<-sb.tbbF[,c("qseqid","saccver","pident","taxids", "origpath","origseq", "K","P","C" ,"O","F","G","S","origgenus","origspecies")]
    sb.tbbF$qseqid<-gsub("_S$","_F",sb.tbbF$qseqid)
  }
  
  if(TaxlevelTest[h]=="S") sb.splS<-sb #else sb.spl<-split(sb,sb$qseqid)
}

sb2<-rbind(sb.splS,sb.tbbG,sb.tbbF)

write.table(sb2,"tempBLASTDB.ALL.tsv",quote = F,row.names = F,sep = "\t")

  }
  
  if("threshbin" %in% threshersteps){
    
    sb2<-data.table::fread(sb2,data.table = F)

#loop bin at all levels
#binning settings to loop through
tops<-c(0,1,2,10,100)
#order=S,G,F,AF
pidents.list<-list(strict=c(99,97,95,90),medium=c(98,96,93,88),relaxed=c(93,85,81,80)) 

binfile.list<-list()
countloop<-0
for(j in 1:length(tops)){
  for(k in 1:length(pidents.list)){
    binfile<-paste0("top_",tops[j],".pidents_",paste(pidents.list[[k]],collapse = "."))
    countloop<-countloop+1
    binfile.list[[countloop]]<-binfile
    argsmbk<-c("-i","tempBLASTDB.ALL.tsv", "-o",binfile,"--no_mbk")
    argsmbk<-c(argsmbk,"-S", pidents.list[[k]][1],"-G", pidents.list[[k]][2],"-F", pidents.list[[k]][3],"-A", pidents.list[[k]][4],
               "--TopSpecies", tops[j],"--TopGenus",
               tops[j],"--TopFamily", tops[j]
               ,"--TopAF", tops[j])
    if(!is.null(known_flags)) argsmbk<-c(argsmbk,"--FilterFile",known_flags,"--FilterCol","saccver")
    system2("metabin",argsmbk, wait=T)
  }
}

outfiles<-do.call(c,binfile.list)

#set metabin args
# if(!is.null(SpeciesBL)) argsmbk<-c(argsmbk,"--SpeciesBL",SpeciesBL)
# if(!is.null(GenusBL)) argsmbk<-c(argsmbk,"--GenusBL",GenusBL)
# if(!is.null(FamilyBL)) argsmbk<-c(argsmbk,"--FamilyBL",FamilyBL)
#######################################################

#read metabin results and merge with sb
results<-list()
sb3<-sb2[!duplicated(sb2$qseqid),]

for(i in 1:length(outfiles)){
  a<-data.table::fread(paste0(outfiles[i],".tsv"),data.table = F)
  a$binpath<-paste(a$K,a$P,a$C,a$O,a$F,a$G,a$S,sep = ";")
  sb4<-merge(sb3[,c("qseqid","origpath")],a[,c("qseqid","binpath")],all.x = T,all.y = F,by = "qseqid")
  sb4$settings<-outfiles[i]
  results[[i]]<-sb4
}

results<-do.call(rbind, results)

results$level<-substr(results$qseqid,nchar(results$qseqid),nchar(results$qseqid))
results$binpathS<-results$binpath
results$binpathG<-path.at.level(results$binpathS,level = "G")
results$binpathF<-path.at.level(results$binpathS,level = "F")
results$origpathS<-results$origpath
results$origpathG<-path.at.level(results$origpathS,level = "G")
results$origpathF<-path.at.level(results$origpathS,level = "F")

final.table<-results

final.table$no.hits<-FALSE

#correct 
final.table$correctS<-final.table$binpathS==final.table$origpathS
final.table$correctG<-final.table$binpathG==final.table$origpathG
final.table$correctF<-final.table$binpathF==final.table$origpathF

#above desired rank (doesnt check if above rank is correct...)
final.table$aboveS<-bas.get.ranks(data.frame(taxon=final.table$binpathS))
final.table$aboveG<-bas.get.ranks(data.frame(taxon=paste0(final.table$binpathG,";NA")))
final.table$aboveF<-bas.get.ranks(data.frame(taxon=paste0(final.table$binpathF,";NA;NA")))

final.table[(final.table$aboveF=="htf") & final.table$level=="F","aboveF"]<-"above"
final.table[(final.table$aboveG=="htf" | final.table$aboveG=="family") & final.table$level=="G","aboveG"]<-"above"
final.table[(final.table$aboveS=="htf" | final.table$aboveS=="family" | final.table$aboveS=="genus") & 
              final.table$level=="S","aboveS"]<-"above"

#incorrect
final.table$incorrectS<-(!final.table$correctS) & final.table$aboveS=="species"
final.table$incorrectG<-(!final.table$correctG) & final.table$aboveG=="genus"
final.table$incorrectF<-(!final.table$correctF) & final.table$aboveF=="family"

#change above from "above" to T/F
final.table$aboveS<-final.table$aboveS!="species"
final.table$aboveG<-final.table$aboveG!="genus"
final.table$aboveF<-final.table$aboveF!="family"

#failed
final.table$failedS<-final.table$binpathS=="NA;NA;NA;NA;NA;NA;NA"
final.table$failedG<-final.table$binpathG=="NA;NA;NA;NA;NA;NA"
final.table$failedF<-final.table$binpathF=="NA;NA;NA;NA;NA"

#if failed, other outcomes are NA
final.table[final.table$failedS==TRUE,c("correctS","aboveS","incorrectS")]<-NA
final.table[final.table$failedG==TRUE,c("correctG","aboveG","incorrectG")]<-NA
final.table[final.table$failedF==TRUE,c("correctF","aboveF","incorrectF")]<-NA

#final.table$settings<-paste0(final.table$Spident,"_",final.table$Gpident,"_",final.table$Fpident,"_top",final.table$top)

write.table(final.table,final.table.out,quote = F,sep = "\t",row.names = F)

#print incorrects
incorrects<-list()
incorrects2<-list()
require(tidyverse)
for(i in 1:length(unique(final.table$level))){
  levelincor<-unique(final.table$level)[i]
  finalincor<-final.table[final.table$level==levelincor,]
  #remove failed
  finalincor<-finalincor[!is.na(finalincor$correctS),]
  
  for(j in 1:length(unique(finalincor$settings))){
    finalsets<-unique(finalincor$settings)[j]
    finalincorset<-finalincor[(finalincor$settings==finalsets & finalincor[,paste0("incorrect",levelincor)]==TRUE),]
    if(nrow(finalincorset)>0) incorrects[[j]]<-finalincorset[,c(paste0("origpath",levelincor),paste0("binpath",levelincor),"qseqid")]
    incorrects<-incorrects %>% discard(is.null)
  }
  
  if(length(incorrects)>0) {
    incorrects2[[i]]<-do.call(rbind,incorrects)
    colnames(incorrects2[[i]])<-c("origpath","binpath","qseqid")
  } else incorrects2[[i]]<-NULL
  
}

incorrects2<-incorrects2 %>% discard(is.null)
incorrectsdf<-do.call(rbind,incorrects2)
incorrectsdf<-incorrectsdf[!duplicated(incorrectsdf$qseqid),]
message("Results flagged as incorrect:")
print(incorrectsdf)


  }
  
  if("threshplots" %in% threshersteps) {
#summary counts

allcounts<-list()

for(j in 1:length(unique(final.table$level))){
  
  current.level<-unique(final.table$level)[j]
  
  final.tableS<-final.table[final.table$level==current.level,]
  
  nsettings<-length(unique(final.tableS$settings))
  
  countsS<-data.frame(settings=rep("none",nsettings)
                      ,no_hits=rep(0,nsettings),
                      correct=rep(0,nsettings)
                      ,above=rep(0,nsettings),
                      incorrect=rep(0,nsettings),
                      failed=rep(0,nsettings)
  )
  
  countsS$settings<-as.character(countsS$settings)
  
  countsS$level<-current.level
  
  for(i in 1:length(unique(final.tableS$settings))){
    current.setting<-unique(final.tableS$settings)[i]
    countsS$settings[i]<-current.setting
    countsS$no_hits[i]<-sum(final.tableS[final.tableS$settings==current.setting,"no.hits"])
    
    final.tableSx<-final.tableS[final.tableS$no.hits==FALSE,]
    
    countsS$correct[i]<-sum(final.tableSx[final.tableSx$settings==current.setting,paste0("correct",current.level)],na.rm = T)
    countsS$incorrect[i]<-sum(final.tableSx[final.tableSx$settings==current.setting,paste0("incorrect",current.level)],na.rm = T)
    countsS$above[i]<-sum(final.tableSx[final.tableSx$settings==current.setting,paste0("above",current.level)],na.rm = T)
    countsS$failed[i]<-sum(final.tableSx[final.tableSx$settings==current.setting,paste0("failed",current.level)],na.rm = T)
  }
  
  allcounts[[j]]<-countsS
  
}

allcounts<-do.call(rbind,allcounts)

allcounts$sum<-rowSums(allcounts[,c("no_hits","correct","above","incorrect","failed")])

write.table(allcounts,counts.out,quote = F,sep = "\t",row.names = F)

#######################################################
#PLOTTING 
allcounts$settings<-paste0(allcounts$settings,allcounts$level)

longcount<-reshape2::melt(allcounts[,c("no_hits","correct","above","incorrect","failed","settings")],id.vars="settings")

plot.cols<-c("gray70","yellow4","khaki2","#E31A1C","darkturquoise","green1")
count.plot<-ggplot(data=longcount , aes(y=value, x=settings, fill=variable))+geom_bar(stat = "identity")+
  theme(legend.title = element_text(size=10), legend.text=element_text(size=10),
        axis.text.x=element_text(size=8,angle=45, hjust=1),legend.position="right",legend.direction="vertical") +
  scale_fill_manual(values = plot.cols) 
#geom_text(aes(label = paste(round(value/total.reads*100,digits = 0),"%")), 
#         position = position_stack(vjust = 0.5), size = 2)

count.plot

#############################################  
#plot by taxon, optional filter by taxa  

out.plot.list<-list()

final.table.list<-split(final.table,final.table$level)

for(i in 1:length(final.table.list)){
  
  xx<-final.table.list[[i]]
  
  levelxx<-xx[1,c("level")]
  longcount<-reshape2::melt(xx[,c("no.hits",paste0("correct",levelxx),paste0("above",levelxx),paste0("incorrect",levelxx),
                                  paste0("failed",levelxx)
                                  ,"settings",paste0("origpath",levelxx))],
                            id.vars=c("settings",paste0("origpath",levelxx)))
  
  colnames(longcount)[2]<-"origpathS"
  
  #extract table to limit by taxon
  if(!is.null(limit.plot.to.taxon)){
    indexTax<-match(limit.plot.to.taxon[2],table = c("K","P","C","O","F","G","S"))
    longcount<-longcount[do.call(rbind,stringr::str_split(longcount$origpathS,";"))[,indexTax]==limit.plot.to.taxon[1],]
  }
  
  #plot at level
  indexn<-match(plot.at.level,table = c("K","P","C","O","F","G","S"))
  longcount$plotpath<-do.call(rbind,stringr::str_split(longcount$origpathS,";"))[,indexn]
  
  #sublabel
  if(levelxx=="S") sublabel<-"Binning outcomes if species is in database"
  if(levelxx=="G") sublabel<-"Binning outcomes if species is not in database"
  if(levelxx=="F") sublabel<-"Binning outcomes if genus is not in database"
  
  #plot
  plot.cols<-c("gray70","yellow4","khaki2","#E31A1C","darkturquoise","green1")
  count.plot<-ggplot(data=longcount , aes(y=as.numeric(as.logical(value)), x=settings, fill=variable))+geom_bar(stat = "identity")+
    theme(legend.title = element_text(size=10), legend.text=element_text(size=10),
          axis.text.x=element_text(size=8,angle=45, hjust=1),legend.position="right",legend.direction="vertical") +
    scale_fill_manual(values = plot.cols) +
    facet_wrap(~plotpath,scales = "free") + 
    ggtitle(paste0("TestLevel=",levelxx,"; limit=",limit.plot.to.taxon[1],"; PlotLevel=",plot.at.level), subtitle = sublabel)
  
  
  out.plot.list[[i]]<-count.plot
  names(out.plot.list)[i]<-levelxx
}

out.plot.list[[1]]
out.plot.list[[2]]
out.plot.list[[3]]

t2<-Sys.time()
  
  t3<-round(difftime(t2,t1,units = "mins"),digits = 2)
  
  message("threshing complete in ",t3," mins")
  }
  
} else message("This step was not set to run")
    
  
```